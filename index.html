<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sperm EXplosion</title>
<style> 
    /* ==========================================================================
       1. デザイン設定
       ========================================================================== */
    :root {
        --bg-color: #f2f2f7;           --card-bg: #ffffff;            --text-color: #1c1c1e;
        --btn-primary-bg: #1c1c1e;     --btn-primary-text: #ffffff;   
        --highlight-color: #007aff;    --danger-color: #ff3b30;       --success-color: #34c759;
        --shadow-color: rgba(0, 0, 0, 0.1);    --tooltip-bg: rgba(40, 40, 40, 0.95);  --tooltip-text: #ffffff;
        --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", sans-serif;
    }

    body.dark {
        --bg-color: #1c1c1e; --card-bg: #2c2c2e; --text-color: #f2f2f7;
        --btn-primary-bg: #e5e5ea; --btn-primary-text: #1c1c1e; --highlight-color: #0a84ff;
        --danger-color: #ff453a; --shadow-color: rgba(0, 0, 0, 0.5); --tooltip-bg: rgba(240, 240, 240, 0.95); --tooltip-text: #1c1c1e;
    }

    body {
        font-family: var(--font-family); background: var(--bg-color); color: var(--text-color); margin: 0;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        min-height: 100vh; overflow: hidden; transition: background 0.3s, color 0.3s;
        user-select: none; touch-action: none;
    }

    /* ヘッダー */
    .game-header-bar {
        width: 100%; max-width: 1000px;
        display: grid; grid-template-columns: 1fr auto 1fr;
        align-items: center; padding: 0 10px 10px 10px; box-sizing: border-box;
        font-size: 20px; font-weight: bold; color: var(--text-color);
        z-index: 100; pointer-events: none;
        transition: max-width 0.8s cubic-bezier(0.25, 1, 0.5, 1);
    }

    #scoreDisplay { justify-self: start; }
    #timeDisplay { justify-self: center; font-variant-numeric: tabular-nums; }
    #livesDisplay { justify-self: end; }
    
    .status-item { pointer-events: auto; display: flex; align-items: center; gap: 8px; }

    /* ボスHPバー */
    #bossHpDisplay { 
        justify-self: center; width: 300px; max-width: 60vw; height: 16px; 
        background: #222; border: 2px solid #fff; border-radius: 10px; 
        overflow: hidden; display:none; pointer-events: auto;
        box-shadow: 0 0 15px rgba(255, 59, 48, 0.3);
        margin: 0 10px;
    }
    #bossHpBar { 
        width: 100%; height: 100%; 
        background: linear-gradient(90deg, #ff3b30, #ffcc00, #34c759); 
        background-size: 200% 100%; background-position: 0% 0%;
        transition: width 0.2s ease-out; 
    }

    /* ゲームコンテナ */
    .game-container {
        position: relative; width: 100%; max-width: 1000px;
        background: #000; box-shadow: 0 10px 30px var(--shadow-color);
        border-radius: 12px; overflow: hidden;
        border: 4px solid transparent; box-sizing: border-box; cursor: pointer;
        min-height: 300px; 
        aspect-ratio: 1000/750;
        transition: max-width 0.8s cubic-bezier(0.25, 1, 0.5, 1), aspect-ratio 0.8s cubic-bezier(0.25, 1, 0.5, 1);
        z-index: 1; touch-action: none;
    }
    
    .game-container.boss-mode {
        max-width: 600px;
        aspect-ratio: 600/1000 !important;
        cursor: none;
    }

    .game-container.drag-over { border-color: var(--highlight-color); opacity: 0.8; }
    canvas { display: block; width: 100%; height: 100%; cursor: none; touch-action: none; }

    /* UIレイヤー */
    .ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; 
        padding: 20px; box-sizing: border-box; z-index: 10;
    }

    .screen-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.75);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        z-index: 50; backdrop-filter: blur(4px); transition: opacity 0.3s;
        pointer-events: auto; color: #fff; cursor: default;
    }
    .screen-overlay.hidden { opacity: 0; pointer-events: none; visibility: hidden; }
    #endScreen, #finalResultScreen { z-index: 2000; }

    h1, p.sub-text { font-size: 56px; margin: 0 0 10px 0; letter-spacing: 0.05em; pointer-events: none; text-align: center; }
    p.sub-text { font-size: 20px; opacity: 0.8; margin-bottom: 10px; }
    .blink { animation: blink 1.5s infinite; }
    @keyframes blink { 50% { opacity: 0.5; } }

    /* ボタン */
    .btn-group { display: flex; gap: 15px; margin-top: 30px; pointer-events: auto; position: relative; z-index: 2000; flex-wrap: wrap; justify-content: center; }
    
    .action-btn {
        background: var(--btn-primary-bg); color: var(--btn-primary-text);
        border: 1px solid rgba(255,255,255,0.2); padding: 10px 20px;
        border-radius: 20px; font-size: 16px; font-weight: bold; cursor: pointer;
        transition: transform 0.1s, opacity 0.2s; display: flex; align-items: center; gap: 6px;
        pointer-events: auto; position: relative;
    }
    .action-btn:hover { transform: scale(1.05); opacity: 0.9; }
    .action-btn:active { transform: scale(0.95); }
    .action-btn svg { width: 18px; height: 18px; fill: currentColor; }

    /* BOSSボタン */
    #bossBtn {
        background: #000; color: #ff3b30; border: 2px solid #ff3b30;
        box-shadow: 0 0 15px #ff3b30; animation: pulseRed 1s infinite;
        padding: 15px 50px; text-transform: uppercase; letter-spacing: 3px; font-size: 24px;
        margin-bottom: 40px; display: none; 
        cursor: pointer; pointer-events: auto;
        border-radius: 30px; z-index: 3000;
    }
    #bossBtn:hover { background: #ff3b30; color: #000; }
    @keyframes pulseRed {
        0% { box-shadow: 0 0 10px #ff3b30, inset 0 0 5px #ff3b30; transform: scale(1); }
        50% { box-shadow: 0 0 25px #ff3b30, inset 0 0 10px #ff3b30; transform: scale(1.05); }
        100% { box-shadow: 0 0 10px #ff3b30, inset 0 0 5px #ff3b30; transform: scale(1); }
    }

    /* 固定ボタン */
    .fixed-btn {
        position: fixed; top: 15px; width: 44px; height: 44px; padding: 0; border-radius: 50%;
        z-index: 3000; pointer-events: auto; background: var(--card-bg); color: var(--text-color);
        border: 1px solid var(--border-color); box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: inline-flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
    }
    .fixed-btn:hover { transform: translateY(-1px); opacity: 0.9; }
    #darkModeBtn { right: 15px; } #muteBtn { right: 70px; } #imgToggleBtn { right: 125px; }
    .fixed-btn svg { width: 22px; height: 22px; fill: currentColor; }
    #muteBtn.muted svg path.sound-wave { display: none; } #muteBtn.muted .mute-x { display: block; }

    /* 通知 */
    #global-tooltip {
        position: fixed; background: var(--tooltip-bg); color: var(--tooltip-text);
        padding: 8px 12px; font-size: 12px; border-radius: 6px; pointer-events: none !important; 
        z-index: 30000; opacity: 0; transition: opacity 0.15s ease; white-space: nowrap; font-weight: 500;
    }
    .toast-notification {
        position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
        background: var(--tooltip-bg); color: var(--tooltip-text); padding: 8px 20px; border-radius: 30px;
        font-size: 14px; font-weight: 600; opacity: 0; pointer-events: none; z-index: 20000;
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    
    #launchMessage {
        position: absolute; bottom: 80px; left: 0; width: 100%; text-align: center;
        color: #fff; font-size: 16px; font-weight: bold; text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20;
    }
    #launchMessage.visible { opacity: 1; animation: blink 1.5s infinite; }
    
    .demo-indicator { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 14px; letter-spacing: 2px; pointer-events: none; }

    /* エフェクト */
    .bomb-flash {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: white; opacity: 0; pointer-events: none; z-index: 1500; transition: opacity 0.1s;
    }
    #whiteoutLayer {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: white; opacity: 0; pointer-events: none; z-index: 1900; transition: opacity 2.0s ease-in;
    }
    
    .instructions-area {
        margin-top: 10px; width: 100%; max-width: 1000px;
        text-align: center; color: var(--text-color);
        font-size: 11px; font-family: monospace; letter-spacing: 1px; line-height: 1.8;
        opacity: 0; transition: opacity 0.5s; pointer-events: none;
        user-select: none;
    }
    .instructions-area.visible { opacity: 0.4; }
</style>
</head>
<body class="dark"> 

<!-- 固定ボタン -->
<button id="imgToggleBtn" class="fixed-btn" aria-label="Toggle Image"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></button>
<button id="muteBtn" class="fixed-btn" aria-label="Toggle Mute">
    <svg viewBox="0 0 24 24">
        <path d="M3 9v6h4l5 5V4L7 9H3z"/>
        <path class="sound-wave" d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        <g class="mute-x" style="display:none"><path d="M16 16l4-4m0 0l-4-4m4 4l-4 4m4 4l-4 4m4 4l-4 4m4-4l-4-4" stroke="currentColor" stroke-width="2" /></g>
    </svg>
</button>
<button id="darkModeBtn" class="fixed-btn" aria-label="Toggle Theme"><svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c4.97 0 9-4.03 9-9a9 9 0 0 0-9-9z"/></svg></button>

<!-- ヘッダー -->
<div class="game-header-bar" id="headerBar">
    <div class="status-item" id="scoreDisplay">SCORE: 0</div>
    <div class="status-item" id="timeDisplay">00:00</div>
    <div class="status-item" id="bossHpDisplay"><div id="bossHpBar"></div></div>
    <div class="status-item" id="livesDisplay"><span style="color: var(--danger-color)">♥♥♥</span></div>
</div>

<!-- ゲーム画面 -->
<div class="game-container" id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <div id="launchMessage"></div>
    </div>
    <div id="bombFlash" class="bomb-flash"></div>
    <div id="whiteoutLayer"></div>

    <!-- スタート画面 -->
    <div id="startScreen" class="screen-overlay">
        <h1 id="titleStart">BLOCK BREAKER</h1>
        <p class="sub-text blink" id="subStart">Click to Start</p>
    </div>

    <!-- Stage 1 リザルト -->
    <div id="endScreen" class="screen-overlay hidden">
        <button id="bossBtn" class="action-btn">WARNING: BOSS BATTLE</button>
        
        <h1 id="endTitle">GAME OVER</h1>
        <p class="sub-text" id="endScore">Score: 0</p>
        <p class="sub-text" id="endTime">Time: 0:00</p> 
        <p class="sub-text" id="timeBonus" style="font-size:16px; color:var(--highlight-color); display:none;">Time Bonus: x1.0</p>
        
        <div class="btn-group">
             <button id="tweetBtn" class="action-btn">
                <svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg>
                <span id="lblTweet">Post</span>
            </button>
             <button id="viewBgBtn" class="action-btn"><span id="lblViewBg">View Image</span></button>
             <button id="retryBtn" class="action-btn">
                <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                <span id="lblRetry">Retry</span>
             </button>
        </div>
    </div>

    <!-- Stage 2 リザルト -->
    <div id="finalResultScreen" class="screen-overlay hidden">
        <h1 id="finalTitle" style="color: #ff69b4; text-shadow: 0 0 20px #ff69b4;">SEX COMPLETE</h1>
        <p class="sub-text" id="finalSubText">Thank you for playing‼</p>
        <p class="sub-text" id="finalTotalScore">Total Score: 0</p>
        <div class="btn-group">
            <button class="action-btn" id="tweetFinalBtn">
                <svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg>
                Post to X
            </button>
            <button class="action-btn" onclick="location.reload()">Back to Title</button>
        </div>
    </div>
</div>

<div class="instructions-area" id="tutorialText">
    MOVE: WASD / Mouse &nbsp; SHOOT: Click / Space &nbsp; BOMB: Right Click / Shift
</div>

<script>
// =============================================================================
// 安全な起動のためのラッパー（DOMContentLoaded）
// =============================================================================
window.addEventListener('DOMContentLoaded', () => {

    // =============================================================================
    // Settings & Config
    // =============================================================================
    const USER_SETTINGS = {
        // ==========================================
        // 基本設定（画像・URL）
        // ==========================================
        // 背景画像のURL
        backgroundImage: "https://cdn.gamerch.com/contents/wiki/4707/entry/24XnbuoP.jpg",
        // ブロックに重ねる画像のURL
        blockOverlayImage: "https://cdn.gamerch.com/contents/wiki/4707/entry/lUMPD61O.jpg",
        // シェア時に記載されるURL
        shareUrl: "https://okkiioshiri.github.io/stylish-block-breaker/",
        
        // ==========================================
        // テキスト・メッセージ設定
        // ==========================================
        TEXT: {
            // --- ゲーム内UI ---
            scoreLabel: "SCORE:",
            livesSymbol: "♥",
            launchMessage: "CLICK TO LAUNCH",
            demoIndicator: "DEMO PLAY (AUTO)",
            
            // --- タイトル・勝敗画面 ---
            titleStart: "Sperm EXplosion",
            subStart: "Click to Start",
            titleGameOver: "GAME OVER",
            titleGameWin: "Congratulations!",
            
            // --- リザルト詳細 ---
            resultScore: "Score:",
            resultTime: "Time:",
            resultTimeBonus: "Time Bonus:",
            
            // --- ボタン表示名 ---
            btnPost: "Post",
            btnViewBg: "View Image",
            btnRetry: "Retry",
            
            // --- SNSシェア設定 ---
            shareResultWin: "Stage 1 Cleared!",
            shareResultLose: "Game Over",
            shareHashTags: "SpermEXplosion",
            
            // --- システムメッセージ（通知） ---
            msgBgChanged: "背景画像を変更しました",
            msgBgReset: "背景をリセットしました",
            msgNoImage: "画像が設定されていません",
            msgBlockImgOn: "ブロック: 画像モード",
            msgBlockImgOff: "ブロック: モザイクモード",
            msgViewBg: "画面クリックで戻ります",
            
            // --- ツールチップ（ボタンの説明） ---
            tooltipImgBtn: "ブロック画像を変更",
            tooltipMuteBtn: "ミュート切替",
            tooltipDarkBtn: "ダークモード切替",
            
            // --- アイテム取得時のテキスト ---
            itemSpeedUp: "SPEED UP (+1000pts)",
            itemMultiBall: "MULTI BALL (+500pts)",
            itemExpand: "WIDTH x2 (+500pts)",
            itemShrink: "WIDTH 1/2 (+1000pts)",
            itemLifeUp: "EXTRA LIFE (+500pts)",
            itemSuper: "SUPER SPERM EXPLOSION! (+5000pts)",
            itemBomb: "BOMB BALL (1 HIT) (+500pts)"
        }
    };

    const GAME_CONFIG = {
        baseWidth: 1000, safeZoneHeight: 150,
        paddle: { width: 80, height: 16, color: '#fff', bottomOffset: 30, highlightColor: '#007aff' },
        ball: { radius: 4, color: '#fff', bombColor: '#ff3b30', normalSpeed: 2.5, fastSpeed: 9, smashSpeedMultiplier: 2.0 }, 
        blocks: { cols: 32, rowHeight: 14, opacity: 0.5, offsetTop: 0 },
        egg: { radius: 14, innerColor: 'rgba(255, 105, 180, 1)', membraneColor: 'rgba(255, 255, 255, 0.2)', glowColor: '#ff69b4', speed: 1.2, wanderRows: 10 },
        explosion: { rangeX: 2.5, rangeY: 5.5 },
        colors: ['#f0f0f0', '#e0e0e0', '#d0d0d0', '#c0c0c0', '#b0b0b0', '#a0a0a0', '#909090', '#808080', '#707070', '#606060'],
        score: { block: 100, paddleHit: 10, smashHit: 50, death: -1000, implantation: 5000 },
        items: { probability: 0.1, dropSpeed: 0.5, types: [
                { type: 'speedup', color: '#00e5ff', text: USER_SETTINGS.TEXT.itemSpeedUp, score: 1000, weight: 20 },
                { type: 'multiball', color: '#ffcc00', text: USER_SETTINGS.TEXT.itemMultiBall, score: 500, weight: 20 },
                { type: 'expand', color: '#32d74b', text: USER_SETTINGS.TEXT.itemExpand, score: 500, weight: 15 },
                { type: 'shrink', color: '#a93bd9', text: USER_SETTINGS.TEXT.itemShrink, score: 1000, weight: 20 },
                { type: 'bomb', color: '#cc0d02', text: USER_SETTINGS.TEXT.itemBomb, score: 500, weight: 10 },
                { type: 'lifeup', color: '#e36b82', text: USER_SETTINGS.TEXT.itemLifeUp, score: 500, weight: 10 },
                { type: 'super_explosion', color: 'rainbow', text: USER_SETTINGS.TEXT.itemSuper, score: 5000, weight: 5 }
        ]},
        ai: { smashChance: 0.015, launchChance: 0.05, reactionBias: 0.15, itemPriorityY: 0.3, safeDistance: 350 }
    };
    GAME_CONFIG.defaultBg = USER_SETTINGS.backgroundImage; GAME_CONFIG.blocks.overlayImage = USER_SETTINGS.blockOverlayImage;

    // =============================================================================
    // Sound Manager
    // =============================================================================
    const SoundManager = {
        ctx: null, isMuted: false,
        init() { if (!this.ctx) { try { const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC(); } catch(e){} } if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
        toggleMute() { this.isMuted = !this.isMuted; document.getElementById('muteBtn').classList.toggle('muted', this.isMuted); },
        play(type) {
            if (this.isMuted || !this.ctx) return;
            if (this.ctx.state === 'suspended') this.ctx.resume().catch(()=>{});
            const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            const vol = 0.05; 
            
            if (type === 'heavy_explosion') {
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.frequency.value = 150; 
                osc.type = 'triangle'; osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(60, t); osc.frequency.exponentialRampToValueAtTime(10, t + 1.5);
                gain.gain.setValueAtTime(vol * 0.8, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
                osc.start(t); osc.stop(t + 1.2);
                
                const subOsc = this.ctx.createOscillator(); const subGain = this.ctx.createGain();
                subOsc.type = 'sine'; subOsc.connect(subGain); subGain.connect(this.ctx.destination);
                subOsc.frequency.setValueAtTime(40, t); subOsc.frequency.linearRampToValueAtTime(5, t + 2.0);
                subGain.gain.setValueAtTime(vol * 1.0, t); subGain.gain.exponentialRampToValueAtTime(0.001, t + 2.0);
                subOsc.start(t); subOsc.stop(t + 2.0);
                return;
            }

            osc.connect(gain); gain.connect(this.ctx.destination);
            if (type === 'launch') { osc.frequency.setValueAtTime(440,t); osc.frequency.linearRampToValueAtTime(880,t+0.1); gain.gain.setValueAtTime(vol,t); gain.gain.linearRampToValueAtTime(0,t+0.2); osc.start(t); osc.stop(t+0.2); }
            else if (type === 'smash') { osc.type='sawtooth'; osc.frequency.setValueAtTime(150,t); osc.frequency.exponentialRampToValueAtTime(40,t+0.2); gain.gain.setValueAtTime(vol*1.5,t); gain.gain.exponentialRampToValueAtTime(0.01,t+0.2); osc.start(t); osc.stop(t+0.2); }
            else if (type === 'hit') { osc.type='sine'; osc.frequency.setValueAtTime(600,t); osc.frequency.exponentialRampToValueAtTime(300,t+0.1); gain.gain.setValueAtTime(vol,t); gain.gain.linearRampToValueAtTime(0,t+0.1); osc.start(t); osc.stop(t+0.1); }
            else if (type === 'block') { osc.type='square'; osc.frequency.setValueAtTime(800+Math.random()*200,t); gain.gain.setValueAtTime(vol*0.3,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.08); osc.start(t); osc.stop(t+0.08); }
            else if (type === 'item') { osc.type='triangle'; osc.frequency.setValueAtTime(1200,t); osc.frequency.linearRampToValueAtTime(1800,t+0.1); gain.gain.setValueAtTime(vol,t); gain.gain.linearRampToValueAtTime(0,t+0.2); osc.start(t); osc.stop(t+0.2); }
            else if (type === 'die') { osc.type='sawtooth'; osc.frequency.setValueAtTime(200,t); osc.frequency.exponentialRampToValueAtTime(50,t+0.3); gain.gain.setValueAtTime(vol,t); gain.gain.linearRampToValueAtTime(0,t+0.3); osc.start(t); osc.stop(t+0.3); }
            else if (type === 'win') { const notes=[523.25,587.33,659.25,783.99,880.00,1046.50]; let st=t; notes.forEach((f,i)=>{ const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type='square'; o.connect(g); g.connect(this.ctx.destination); o.frequency.setValueAtTime(f,st); g.gain.setValueAtTime(vol,st); g.gain.exponentialRampToValueAtTime(0.01,st+(i===5?0.8:0.08)-0.01); o.start(st); o.stop(st+(i===5?0.8:0.08)); st+=(i===5?0.8:0.08); }); }
        }
    };

    // =============================================================================
    // Performance Systems (Pooling & Batching)
    // =============================================================================
    class ParticleSystem {
        constructor(maxSize = 2000) {
            this.pool = [];
            for (let i = 0; i < maxSize; i++) {
                this.pool.push({ active: false, x: 0, y: 0, dx: 0, dy: 0, life: 0, color: '#fff', size: 3 });
            }
        }
        spawn(x, y, color, life = 1.0, speed = 5, size = 3) {
            const p = this.pool.find(p => !p.active);
            if (!p) return;
            p.active = true; p.x = x; p.y = y; p.color = color; p.life = life; p.size = size;
            const angle = Math.random() * Math.PI * 2;
            const s = Math.random() * speed;
            p.dx = Math.cos(angle) * s; p.dy = Math.sin(angle) * s;
        }
        spawnDirected(x, y, dx, dy, color, life = 1.0, size = 3) {
            const p = this.pool.find(p => !p.active);
            if (!p) return;
            p.active = true; p.x = x; p.y = y; p.color = color; p.life = life; p.size = size;
            p.dx = dx; p.dy = dy;
        }
        update() {
            for (let i = 0; i < this.pool.length; i++) {
                const p = this.pool[i];
                if (!p.active) continue;
                p.x += p.dx; p.y += p.dy; p.life -= 0.02;
                if (p.life <= 0) p.active = false;
            }
        }
        draw(ctx) {
            for (let i = 0; i < this.pool.length; i++) {
                const p = this.pool[i];
                if (!p.active) continue;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.rect(p.x, p.y, p.size, p.size);
                ctx.fill();
            }
        }
        clear() { this.pool.forEach(p => p.active = false); }
    }

    class BulletSystem {
        constructor(maxSize = 1000) {
            this.pool = [];
            for (let i = 0; i < maxSize; i++) {
                this.pool.push({ active: false, x: 0, y: 0, dx: 0, dy: 0, isEnemy: false, color: '#fff', r: 4 });
            }
        }
        spawn(x, y, opts = {}) {
            const b = this.pool.find(item => !item.active);
            if (!b) return null;
            b.active = true; b.x = x; b.y = y;
            b.isEnemy = opts.isEnemy || false;
            b.r = b.isEnemy ? 5 : (opts.size || 4);
            b.color = opts.color || (b.isEnemy ? '#ff3b30' : '#fff');
            const s = opts.speed || (b.isEnemy ? 2 : 12);
            const a = opts.angle !== undefined ? opts.angle : (b.isEnemy ? Math.PI/2 : -Math.PI/2);
            b.dx = Math.cos(a) * s; b.dy = Math.sin(a) * s;
            return b;
        }
        update(cw, ch) {
            for (let i = 0; i < this.pool.length; i++) {
                const b = this.pool[i];
                if (!b.active) continue;
                b.x += b.dx; b.y += b.dy;
                if (b.y < -50 || b.y > ch + 50 || b.x < -50 || b.x > cw + 50) b.active = false;
            }
        }
        draw(ctx) {
            for (let i = 0; i < this.pool.length; i++) {
                const b = this.pool[i];
                if (!b.active) continue;
                ctx.fillStyle = b.color;
                ctx.shadowColor = b.color; 
                ctx.shadowBlur = 5; 
                ctx.beginPath();
                ctx.moveTo(b.x + b.r, b.y);
                ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
        }
        getActiveBullets() { return this.pool.filter(b => b.active); }
        clear() { this.pool.forEach(b => b.active = false); }
    }

    // =============================================================================
    // Classes
    // =============================================================================
    class InputHandler {
        constructor(game) { 
            this.game = game; this.canvasRect = null; 
            this.handleMoveRef = (e) => this.handleMove(e.clientX);
            this.handleTouchMoveRef = (e) => { if(!this.game.isDemo){ e.preventDefault(); if(e.touches[0]) this.handleMove(e.touches[0].clientX); } };
            this.handleClickRef = (e) => this.handleClick(e);
            this.handleTouchStartRef = (e) => { if(!e.target.closest('button')){ e.preventDefault(); this.handleClick(e); if(!this.game.isDemo && e.touches[0]) this.handleMove(e.touches[0].clientX); } };
            this.handleKeyRef = (e) => this.handleKey(e);
            this.handleResizeRef = () => this.updateRect();
            this.init(); 
        }
        init() {
            const c = document.getElementById('gameContainer');
            c.addEventListener('contextmenu', e => e.preventDefault()); 
            window.addEventListener('resize', this.handleResizeRef); window.addEventListener('scroll', this.handleResizeRef);
            window.addEventListener('mousemove', this.handleMoveRef);
            c.addEventListener('touchmove', this.handleTouchMoveRef, {passive:false});
            c.addEventListener('mousedown', this.handleClickRef);
            c.addEventListener('touchstart', this.handleTouchStartRef, {passive:false});
            document.addEventListener('keydown', this.handleKeyRef);
            c.addEventListener('dragover', e => {e.preventDefault(); e.stopPropagation(); c.classList.add('drag-over');});
            c.addEventListener('dragleave', e => {e.preventDefault(); e.stopPropagation(); c.classList.remove('drag-over');});
            c.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); c.classList.remove('drag-over'); const f = e.dataTransfer.files[0]; if(f && f.type.startsWith('image/')) this.game.loadBackground(f); });
            this.updateRect();
        }
        destroy() {
            const c = document.getElementById('gameContainer');
            window.removeEventListener('resize', this.handleResizeRef); window.removeEventListener('scroll', this.handleResizeRef);
            window.removeEventListener('mousemove', this.handleMoveRef);
            c.removeEventListener('touchmove', this.handleTouchMoveRef);
            c.removeEventListener('mousedown', this.handleClickRef);
            c.removeEventListener('touchstart', this.handleTouchStartRef);
            document.removeEventListener('keydown', this.handleKeyRef);
        }
        updateRect() { const c = document.getElementById('gameCanvas'); if(c) this.canvasRect = c.getBoundingClientRect(); }
        handleMove(cx) { 
            if(this.game.isDemo || (this.game.state && this.game.state.startsWith('STAGE2'))) return; 
            if(!this.canvasRect || this.canvasRect.width === 0) this.updateRect(); 
            if(this.canvasRect) this.game.paddle.x = (cx - this.canvasRect.left) * (this.game.canvas.width / this.canvasRect.width) - this.game.paddle.width / 2; 
        }
        handleClick(e) { if(e.target.closest('button')) return; if(this.game.state && this.game.state.startsWith('STAGE2')) return; SoundManager.init(); this.game.handleClick(); }
        handleKey(e) { 
            if(this.game.state && this.game.state.startsWith('STAGE2')) return; 
            if((e.key === 'd' || e.key === 'D') && this.game.state === 'MENU') this.game.startDemo(); 
            if(this.game.isDemo && this.game.state === 'PLAYING') { const k = parseInt(e.key); if(k > 0 && k <= 7) this.game.forceDropItem(k-1); }
            if((e.key === 'b' || e.key === 'B') && this.game.state === 'MENU') { e.preventDefault(); this.game.debugQuickWin(); }
        }
    }

    class AIController {
        constructor(game) { this.game = game; }
        update() {
            const balls = this.game.balls; const egg = this.game.egg; const paddle = this.game.paddle; const height = this.game.canvas.height;
            let targetBall = null; let maxScore = -Infinity;
            balls.forEach(b => { if (b.active) { let score = b.y; if (b.dy > 0) score += 500; if (egg && Math.sqrt((b.x - egg.x)**2 + (b.y - egg.y)**2) < 200) score += 200; if (score > maxScore) { maxScore = score; targetBall = b; } } });
            let targetX = paddle.x + paddle.width / 2;
            if (targetBall) { targetX = targetBall.x; if (targetBall.dy > 0 && targetBall.y > height - 250 && this.game.pushTimer === 0 && Math.random() < GAME_CONFIG.ai.smashChance) { this.game.pushTimer = 10; } }
            let bestItem = null; let minDist = Infinity; const currentTargetX = targetBall ? targetBall.x : targetX;
            this.game.items.forEach(i => { if (i.y > height * GAME_CONFIG.ai.itemPriorityY) { let d = Math.abs(i.x - currentTargetX); if (d < minDist) { minDist = d; bestItem = i; } } });
            if (bestItem) { const isSafe = !targetBall || targetBall.dy < 0 || targetBall.y < height - GAME_CONFIG.ai.safeDistance; if (isSafe) { targetX = bestItem.x; } else if (Math.abs(bestItem.x - targetX) < 120) { targetX = targetX * 0.6 + bestItem.x * 0.4; } }
            paddle.x += (targetX + Math.sin(Date.now() * 0.005) * 15 - (paddle.x + paddle.width / 2)) * GAME_CONFIG.ai.reactionBias;
            if (balls.find(b => b.isAttached) && Math.random() < GAME_CONFIG.ai.launchChance) { this.game.tryLaunch(); }
        }
    }

    class Paddle {
        constructor(width) { this.width = width; this.x = 0; }
        draw(ctx, y, height, isHighlight) { ctx.fillStyle = GAME_CONFIG.paddle.color; if (isHighlight) { ctx.shadowBlur = 20; ctx.shadowColor = GAME_CONFIG.paddle.highlightColor; } else ctx.shadowBlur = 0; ctx.fillRect(this.x, y, this.width, height); ctx.shadowBlur = 0; }
    }

    class Ball {
        constructor(x, y, isAttached) { this.x = x; this.y = y; this.dx = 0; this.dy = 0; this.radius = GAME_CONFIG.ball.radius; this.active = true; this.isAttached = isAttached; this.isSmashing = false; this.trail = []; }
        draw(ctx, isBomb) {
            if (!this.active) return;
            if (this.isSmashing && this.trail.length) { ctx.shadowColor = 'rgba(0,191,255,0.5)'; ctx.shadowBlur = 4; ctx.beginPath(); this.trail.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); }); ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = this.radius * 2; ctx.stroke(); ctx.shadowBlur = 0; }
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.isAttached ? -Math.PI / 2 : Math.atan2(this.dy, this.dx));
            const bc = isBomb ? GAME_CONFIG.ball.bombColor : GAME_CONFIG.ball.color; ctx.shadowColor = isBomb ? 'rgba(255,0,0,1)' : 'rgba(0,100,255,0.8)'; ctx.shadowBlur = isBomb ? 25 : 6;
            ctx.fillStyle = bc; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
            if (!this.isAttached) { ctx.beginPath(); ctx.moveTo(0, 0); const tm = Date.now(); for (let i = 0; i <= 25; i += 2) ctx.lineTo(-i, Math.sin(i * 0.3 - tm * 0.07) * (i / 25) * 6); ctx.strokeStyle = bc; ctx.lineWidth = 2; ctx.lineCap = 'round'; ctx.stroke(); }
            ctx.restore();
        }
    }

    // =============================================================================
    // Game (Stage 1)
    // =============================================================================
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
            this.blurredBgCanvas = document.createElement('canvas'); this.state = 'MENU'; this.score = 0; this.lives = 3; this.gameStartTime = 0;
            this.paddle = new Paddle(GAME_CONFIG.paddle.width); this.balls = []; this.blocks = []; this.items = []; 
            this.particleSystem = new ParticleSystem(); 
            this.winParticles = [];
            this.speedUpEndTime = 0; this.bombNextHit = false; this.pushTimer = 0; this.shakeTime = 0;
            this.initDone = false; this.useOverlayImage = !!GAME_CONFIG.blocks.overlayImage;
            this.bgImage = new Image(); this.bgImage.crossOrigin = "anonymous"; this.blockImage = new Image(); this.blockImage.crossOrigin = "anonymous"; if (GAME_CONFIG.blocks.overlayImage) this.blockImage.src = GAME_CONFIG.blocks.overlayImage;
            this.inputHandler = new InputHandler(this); this.aiController = new AIController(this); this.lastTimeStr = ""; this.applyTextSettings();
            
            const startInit = () => { if(this.initDone)return; this.initDone=true; this.resizeAndReset(); };
            if (GAME_CONFIG.defaultBg) { this.bgImage.onload=startInit; this.bgImage.onerror=startInit; this.bgImage.src=GAME_CONFIG.defaultBg; setTimeout(startInit,3000); } else { startInit(); }
            
            this.loop = this.loop.bind(this);
            this.animationFrameId = requestAnimationFrame(this.loop);
        }
        loop() {
            if(this.state !== 'STAGE2_TRANSITION' && this.state !== 'STAGE2_PLAYING') {
                this.update();
                this.draw();
                this.animationFrameId = requestAnimationFrame(this.loop);
            }
        }
        applyTextSettings() {
            const T = USER_SETTINGS.TEXT; document.getElementById('titleStart').textContent = T.titleStart; document.getElementById('subStart').textContent = T.subStart; document.getElementById('launchMessage').textContent = T.launchMessage;
            document.getElementById('imgToggleBtn').setAttribute('data-tooltip', T.tooltipImgBtn); document.getElementById('muteBtn').setAttribute('data-tooltip', T.tooltipMuteBtn); document.getElementById('darkModeBtn').setAttribute('data-tooltip', T.tooltipDarkBtn);
            document.getElementById('lblTweet').textContent = T.btnPost; document.getElementById('lblViewBg').textContent = T.btnViewBg; document.getElementById('lblRetry').textContent = T.btnRetry; this.updateUI();
        }
        resizeAndReset() {
            let h = 600; 
            if(this.bgImage.src && this.bgImage.complete && this.bgImage.naturalWidth > 0) {
                h = Math.floor(GAME_CONFIG.baseWidth * (this.bgImage.naturalHeight/this.bgImage.naturalWidth));
            }
            if(!h || isNaN(h)) h = 600;

            const th = h + GAME_CONFIG.safeZoneHeight; this.canvas.width = GAME_CONFIG.baseWidth; this.canvas.height = th;
            document.getElementById('gameContainer').style.aspectRatio = `${GAME_CONFIG.baseWidth}/${th}`;
            this.inputHandler.updateRect(); setTimeout(() => this.inputHandler.updateRect(), 350); this.createBlurredBackground();
            if(this.state!=='MENU') { this.resetGame(); this.state='PLAYING'; document.getElementById('endScreen').classList.add('hidden'); } else { this.resetLevel(); } this.draw();
        }
        createBlurredBackground() { if(!this.bgImage.src || !this.bgImage.complete || this.bgImage.naturalWidth === 0) return; this.blurredBgCanvas.width = this.canvas.width; this.blurredBgCanvas.height = this.canvas.height; const ctx = this.blurredBgCanvas.getContext('2d'); ctx.filter='blur(8px)'; ctx.drawImage(this.bgImage, -20, -20, this.canvas.width+40, this.canvas.height-GAME_CONFIG.safeZoneHeight+40); ctx.filter='none'; }
        loadBackground(f) { if(this.state.startsWith('STAGE2')) return; const r=new FileReader(); r.onload=e=>{ this.bgImage.onload=()=>{this.useOverlayImage=false;GAME_CONFIG.blocks.overlayImage="";this.blockImage.src="";this.resizeAndReset();}; this.bgImage.src=e.target.result; showToast(USER_SETTINGS.TEXT.msgBgChanged); }; r.readAsDataURL(f); }
        toggleBlockImage() { if(!GAME_CONFIG.blocks.overlayImage){ showToast(USER_SETTINGS.TEXT.msgNoImage); return; } this.useOverlayImage = !this.useOverlayImage; showToast(this.useOverlayImage ? USER_SETTINGS.TEXT.msgBlockImgOn : USER_SETTINGS.TEXT.msgBlockImgOff); this.draw(); }
        handleClick() {
            if(this.isDemo) { this.isDemo=false; this.state='MENU'; document.getElementById('startScreen').classList.remove('hidden'); document.querySelector('.demo-indicator')?.remove(); this.resetGame(); return; }
            if(this.state==='MENU'||this.state==='GAMEOVER'||this.state==='WIN') this.startGame();
            else if(this.state==='VIEW_BG') { this.state='WIN'; document.getElementById('endScreen').classList.remove('hidden'); }
            else if(this.state==='PLAYING') { const b = this.balls.find(b=>b.isAttached); if(b) this.tryLaunch(); else if(this.pushTimer===0) this.pushTimer=10; }
        }
        startGame() { this.isDemo=false; this.resetGame(); this.state='PLAYING'; document.getElementById('startScreen').classList.add('hidden'); document.getElementById('endScreen').classList.add('hidden'); document.getElementById('bossBtn').style.display='none'; document.getElementById('gameContainer').style.cursor='none'; document.querySelector('.demo-indicator')?.remove(); this.showTutorial(); }
        startDemo() { SoundManager.init(); this.isDemo=true; this.resetGame(); this.state='PLAYING'; document.getElementById('startScreen').classList.add('hidden'); document.getElementById('endScreen').classList.add('hidden'); document.getElementById('gameContainer').style.cursor='none'; const d=document.createElement('div'); d.className='demo-indicator'; d.textContent=USER_SETTINGS.TEXT.demoIndicator; document.getElementById('gameContainer').appendChild(d); }
        showTutorial() { const t=document.getElementById('tutorialText'); t.classList.add('visible'); setTimeout(()=>t.classList.remove('visible'), 5000); }
        resetGame() { this.score=0; this.lives=3; this.gameStartTime=Date.now(); this.lastTimeStr=""; this.resetLevel(); this.updateUI(); }
        resetLevel() { this.paddle.width=GAME_CONFIG.paddle.width; this.paddle.x=(this.canvas.width-this.paddle.width)/2; this.items=[]; this.particleSystem.clear(); this.speedUpEndTime=0; this.bombNextHit=false; this.pushTimer=0; this.shakeTime=0; this.winParticles=[]; this.spawnBall(true); this.createBlocks(); this.initEgg(); }
        spawnBall(att=false) { this.balls=[new Ball(this.canvas.width/2, this.canvas.height-40, att)]; if(att){const m=document.getElementById('launchMessage');m.textContent=USER_SETTINGS.TEXT.launchMessage;m.classList.add('visible');} }
        tryLaunch() { const b=this.balls.find(b=>b.isAttached); if(b){ b.isAttached=false; const a=-Math.PI/2+(Math.random()*0.5-0.25); const s=this.getCurrentTargetSpeed(); b.dx=s*Math.cos(a); b.dy=s*Math.sin(a); SoundManager.play('launch'); document.getElementById('launchMessage').classList.remove('visible'); } }
        createBlocks() { this.blocks=[]; const bw=this.canvas.width/GAME_CONFIG.blocks.cols; const h=this.canvas.height-GAME_CONFIG.safeZoneHeight; if(h<=0)return; const rows=Math.floor(h/GAME_CONFIG.blocks.rowHeight); const bh=h/rows; for(let r=0;r<rows;r++){ const c=GAME_CONFIG.colors[Math.floor((r/rows)*GAME_CONFIG.colors.length)%GAME_CONFIG.colors.length]; for(let col=0;col<GAME_CONFIG.blocks.cols;col++) this.blocks.push({x:col*bw,y:GAME_CONFIG.blocks.offsetTop+r*bh,w:bw,h:bh,color:c,active:true}); } }
        initEgg() { const my=GAME_CONFIG.blocks.offsetTop+(GAME_CONFIG.blocks.rowHeight*GAME_CONFIG.egg.wanderRows); this.egg={x:this.canvas.width/2,y:my/2,radius:GAME_CONFIG.egg.radius,dx:GAME_CONFIG.egg.speed,dy:GAME_CONFIG.egg.speed*0.5,maxY:my}; }
        update() {
            if(this.state==='WIN'||this.state==='VIEW_BG') { this.updateWinParticles(); return; }
            if(this.state==='IMPLANTATION') { this.updateImplantation(); return; }
            if(this.state==='PLAYING') {
                const timeStr = this.calculateTime(); if (timeStr !== this.lastTimeStr) { document.getElementById('timeDisplay').textContent = timeStr; this.lastTimeStr = timeStr; }
                if(this.isDemo) this.aiController.update();
                this.updateTimers(); this.updateEgg(); this.updateBalls(); this.updateItems(); this.particleSystem.update(); this.checkWinCondition();
            }
        }
        updateTimers() { if(this.pushTimer>0)this.pushTimer--; if(this.shakeTime>0)this.shakeTime--; }
        updateEgg() { if(!this.egg) return; this.egg.x+=this.egg.dx; this.egg.y+=this.egg.dy; if(this.egg.x<this.egg.radius||this.egg.x>this.canvas.width-this.egg.radius)this.egg.dx*=-1; if(this.egg.y<this.egg.radius||this.egg.y>this.egg.maxY)this.egg.dy*=-1; }
        updateBalls() {
            const po=(this.pushTimer>0)?Math.sin((this.pushTimer/10)*Math.PI)*12:0; const pt=this.canvas.height-GAME_CONFIG.paddle.height-GAME_CONFIG.paddle.bottomOffset-po;
            if(this.paddle.x<0)this.paddle.x=0; if(this.paddle.x+this.paddle.width>this.canvas.width)this.paddle.x=this.canvas.width-this.paddle.width;
            let activeBalls = 0; const ts = this.getCurrentTargetSpeed();
            this.balls.forEach(b => {
                if(!b.active) return; activeBalls++;
                if(b.isAttached){ b.x=this.paddle.x+this.paddle.width/2; b.y=pt-b.radius-2; return; }
                if(this.egg && (b.x-this.egg.x)**2+(b.y-this.egg.y)**2<(b.radius+this.egg.radius)**2) { this.triggerImplantation(b.x,b.y); return; }
                if(b.isSmashing){ b.trail.push({x:b.x,y:b.y}); if(b.trail.length>8)b.trail.shift(); } else b.trail=[];
                const cs=Math.sqrt(b.dx*b.dx+b.dy*b.dy); if(!b.isSmashing&&cs>0) { const s=ts/cs; b.dx*=s; b.dy*=s; } else if(b.isSmashing&&cs<GAME_CONFIG.ball.fastSpeed*1.5) { const s=(GAME_CONFIG.ball.fastSpeed*1.5)/cs; b.dx*=s; b.dy*=s; }
                b.x+=b.dx; b.y+=b.dy; let wallHit=false;
                if(b.x<b.radius){b.x=b.radius;b.dx=Math.abs(b.dx);wallHit=true;} else if(b.x>this.canvas.width-b.radius){b.x=this.canvas.width-b.radius;b.dx=-Math.abs(b.dx);wallHit=true;}
                if(b.y<b.radius){b.y=b.radius;b.dy=Math.abs(b.dy);wallHit=true;} if(wallHit){SoundManager.play('hit');if(b.isSmashing)this.normalizeBallSpeed(b);this.preventHorizontal(b);}
                if(b.dy>0 && b.y+b.radius>=pt && b.y-b.radius<=pt+GAME_CONFIG.paddle.height+po && b.x>=this.paddle.x && b.x<=this.paddle.x+this.paddle.width){
                    const hp=(b.x-(this.paddle.x+this.paddle.width/2))/(this.paddle.width/2); const ang=hp*(Math.PI/3); let sp=Math.sqrt(b.dx*b.dx+b.dy*b.dy);
                    if(this.pushTimer>0){ b.isSmashing=true; sp=GAME_CONFIG.ball.fastSpeed*GAME_CONFIG.ball.smashSpeedMultiplier; this.shakeTime=10; SoundManager.play('smash'); this.score+=GAME_CONFIG.score.smashHit; this.updateUI(); } else { b.isSmashing=false; SoundManager.play('hit'); this.score+=GAME_CONFIG.score.paddleHit; this.updateUI(); } b.dx=sp*Math.sin(ang); b.dy=-sp*Math.cos(ang); b.y=pt-b.radius-1;
                }
                if(b.y>this.canvas.height) b.active=false;
                for(let i=0;i<this.blocks.length;i++){
                    const k=this.blocks[i]; if(!k.active)continue;
                    if(b.x+b.radius>k.x && b.x-b.radius<k.x+k.w && b.y+b.radius>k.y && b.y-b.radius<k.y+k.h){
                        k.active=false; this.score+=GAME_CONFIG.score.block; this.updateUI(); SoundManager.play('block'); this.createParticles(k.x+k.w/2,k.y+k.h/2,k.color);
                        if(Math.random()<GAME_CONFIG.items.probability)this.dropItem(k.x+k.w/2,k.y+k.h/2); if(this.bombNextHit) { this.triggerExplosion(k); this.bombNextHit=false; }
                        const px=b.x-b.dx; if(px+b.radius<=k.x||px-b.radius>=k.x+k.w)b.dx*=-1; else b.dy*=-1; if(b.isSmashing)this.normalizeBallSpeed(b); this.preventHorizontal(b); break;
                    }
                }
            });
            if(activeBalls===0) this.handleDeath();
        }
        updateImplantation() {
            this.shockwaveRadius+=5; this.blocks.forEach(b=>{if(b.active){const bx=b.x+b.w/2,by=b.y+b.h/2;if(Math.sqrt((bx-this.egg.x)**2+(by-this.egg.y)**2)<this.shockwaveRadius){b.active=false;this.createParticles(bx,by,b.color);}}});
            this.particleSystem.update(); if(this.shakeTime>0)this.shakeTime--; if(this.shockwaveRadius>this.shockwaveMaxRadius)this.gameWin();
        }
        updateWinParticles() { this.winParticles.forEach(p=>{p.y+=p.speedY;p.x+=Math.sin(p.sway)*2;p.sway+=0.05;if(p.y>this.canvas.height){p.y=-20;p.x=Math.random()*this.canvas.width;}}); }
        updateItems() {
            const pt = this.canvas.height-GAME_CONFIG.paddle.height-GAME_CONFIG.paddle.bottomOffset-((this.pushTimer>0)?Math.sin((this.pushTimer/10)*Math.PI)*12:0);
            this.items.forEach((it,i)=>{ it.y+=GAME_CONFIG.items.dropSpeed; if(it.y>pt && it.y<pt+GAME_CONFIG.paddle.height && it.x>this.paddle.x && it.x<this.paddle.x+this.paddle.width){ this.activateItem(it); this.items.splice(i,1); } else if(it.y>this.canvas.height)this.items.splice(i,1); });
        }
        getCurrentTargetSpeed() { return (Date.now()<this.speedUpEndTime)?GAME_CONFIG.ball.fastSpeed:GAME_CONFIG.ball.normalSpeed; }
        normalizeBallSpeed(b) { const a=Math.atan2(b.dy,b.dx); const s=this.getCurrentTargetSpeed(); b.dx=s*Math.cos(a); b.dy=s*Math.sin(a); b.isSmashing=false; }
        preventHorizontal(b) { const s=Math.sqrt(b.dx*b.dx+b.dy*b.dy); if(Math.abs(b.dy)<s*0.2) { const sy=b.dy>=0?1:-1; let ny=s*0.2*(b.dy===0?1:sy); b.dy=ny; const sx=b.dx>=0?1:-1; b.dx=sx*Math.sqrt(Math.max(0,s*s-b.dy*b.dy)); } }
        handleDeath() {
            if(this.isDemo) { this.spawnBall(true); } else { 
                this.lives--; this.score = Math.max(0, this.score + GAME_CONFIG.score.death); this.updateUI(); SoundManager.play('die'); 
                if(this.lives > 0) { this.paddle.width = GAME_CONFIG.paddle.width; this.speedUpEndTime = 0; this.bombNextHit = false; this.spawnBall(true); } else { this.gameOver(); }
            }
        }
        checkWinCondition() { if (this.state === 'IMPLANTATION') return; if(this.blocks.length>0 && this.blocks.every(b=>!b.active)) if(this.state!=='WIN') this.gameWin(); }
        triggerExplosion(blk) {
            SoundManager.play('smash'); this.shakeTime=30; const cx=blk.x+blk.w/2, cy=blk.y+blk.h/2; const rx=blk.w*GAME_CONFIG.explosion.rangeX, ry=blk.h*GAME_CONFIG.explosion.rangeY; this.createExplosionParticles(cx, cy); let cnt=0;
            this.blocks.forEach(b=>{ if(!b.active)return; const bx=b.x+b.w/2, by=b.y+b.h/2; if(((bx-cx)**2)/(rx**2)+((by-cy)**2)/(ry**2)<=1) { b.active=false; cnt++; this.score+=GAME_CONFIG.score.block; if(Math.random()<0.5)this.createParticles(bx,by,b.color); if(Math.random()<GAME_CONFIG.items.probability*0.5)this.dropItem(bx,by); } });
            if(cnt>0)this.updateUI();
        }
        triggerImplantation(bx,by) { this.state='IMPLANTATION'; this.shakeTime=120; this.score+=GAME_CONFIG.score.implantation; this.updateUI(); this.shockwaveRadius=0; this.shockwaveMaxRadius=Math.max(this.canvas.width,this.canvas.height)*1.5; for(let i=0;i<30;i++)this.createParticles(this.egg.x,this.egg.y,'#ff99cc'); }
        dropItem(x,y) { const types = GAME_CONFIG.items.types; const totalWeight = types.reduce((sum, item) => sum + (item.weight || 1), 0); let r = Math.random() * totalWeight; for (const item of types) { const w = item.weight || 1; if (r < w) { this.items.push({ x, y, ...item }); return; } r -= w; } }
        forceDropItem(i) { if(i>=0&&i<GAME_CONFIG.items.types.length) this.items.push({x:Math.random()*(this.canvas.width-40)+20, y:80, ...GAME_CONFIG.items.types[i]}); }
        activateItem(item) {
            SoundManager.play('item'); showToast(item.text); this.score+=item.score; this.updateUI();
            if(item.type==='speedup')this.speedUpEndTime=Date.now()+3000; else if(item.type==='multiball'){const b=this.balls.find(z=>z.active&&!z.isAttached);if(b)this.balls.push(new Ball(b.x, b.y, false)); this.balls[this.balls.length-1].dx = -b.dx; this.balls[this.balls.length-1].dy = b.dy; }
            else if(item.type==='expand')this.paddle.width=Math.min(this.paddle.width*2,GAME_CONFIG.paddle.width*2); else if(item.type==='shrink')this.paddle.width=Math.max(this.paddle.width/2,GAME_CONFIG.paddle.width*0.5); else if(item.type==='lifeup'){ if(this.lives < 10) { this.lives++; this.updateUI(); } }
            else if(item.type==='bomb')this.bombNextHit=true; else if(item.type==='super_explosion'){ const b=this.balls.find(z=>z.active)||{x:this.canvas.width/2,y:this.canvas.height/2}; for(let i=0;i<20;i++){const a=(Math.PI*2/20)*i;const s=GAME_CONFIG.ball.normalSpeed*(0.8+Math.random()*0.4); const nb = new Ball(b.x, b.y, false); nb.dx=Math.cos(a)*s; nb.dy=Math.sin(a)*s; this.balls.push(nb); } }
        }
        createParticles(x,y,c){for(let i=0;i<6;i++)this.particleSystem.spawn(x, y, c);}
        createExplosionParticles(x,y){const c=['#f00','#f80','#ff0','#fff'];for(let i=0;i<30;i++){const a=Math.random()*6.28,s=2+Math.random()*6;this.particleSystem.spawnDirected(x,y, Math.cos(a)*s, Math.sin(a)*s, c[Math.floor(Math.random()*4)]);}}
        drawItemIcon(it) {
            const x=it.x,y=it.y,t=it.type; let c=it.color; if(t==='super_explosion')c=`hsl(${(Date.now()/10)%360},100%,50%)`;
            this.ctx.save(); this.ctx.shadowBlur=10; this.ctx.shadowColor=c; this.ctx.strokeStyle=c; this.ctx.lineWidth=2;
            this.ctx.beginPath(); this.ctx.arc(x,y,14,0,Math.PI*2); this.ctx.stroke();
            this.ctx.shadowBlur=0; this.ctx.fillStyle=c; this.ctx.lineCap='round'; this.ctx.lineJoin='round'; this.ctx.beginPath();
            if(t==='speedup'){this.ctx.moveTo(x+2,y-7);this.ctx.lineTo(x-3,y);this.ctx.lineTo(x+2,y);this.ctx.lineTo(x-2,y+7);this.ctx.stroke();}
            else if(t==='multiball'){this.ctx.arc(x-5,y+3,2.5,0,7);this.ctx.closePath();this.ctx.arc(x+5,y+3,2.5,0,7);this.ctx.closePath();this.ctx.arc(x,y-5,2.5,0,7);this.ctx.fill();}
            else if(t==='expand'){this.ctx.moveTo(x-6,y);this.ctx.lineTo(x+6,y);this.ctx.moveTo(x-3,y-3);this.ctx.lineTo(x-6,y);this.ctx.lineTo(x-3,y+3);this.ctx.moveTo(x+3,y-3);this.ctx.lineTo(x+6,y);this.ctx.lineTo(x+3,y+3);this.ctx.stroke();}
            else if(t==='shrink'){this.ctx.moveTo(x-7,y-3);this.ctx.lineTo(x-2,y);this.ctx.lineTo(x-7,y+3);this.ctx.moveTo(x+7,y-3);this.ctx.lineTo(x+2,y);this.ctx.lineTo(x+7,y+3);this.ctx.stroke();}
            else if(t==='lifeup'){this.ctx.font="bold 20px sans-serif";this.ctx.textAlign="center";this.ctx.textBaseline="middle";this.ctx.fillText("♥",x,y+2);}
            else if(t==='super_explosion'){this.ctx.moveTo(x,y-6);this.ctx.lineTo(x,y+6);this.ctx.moveTo(x-6,y);this.ctx.lineTo(x+6,y);this.ctx.moveTo(x-4,y-4);this.ctx.lineTo(x+4,y+4);this.ctx.moveTo(x+4,y-4);this.ctx.lineTo(x-4,y+4);this.ctx.stroke();}
            else if(t==='bomb'){this.ctx.beginPath();this.ctx.arc(x,y+2,6,0,7);this.ctx.fill();this.ctx.beginPath();this.ctx.moveTo(x+2,y-2);this.ctx.quadraticCurveTo(x+6,y-6,x+8,y-4);this.ctx.stroke();this.ctx.fillStyle='#fc0';this.ctx.beginPath();this.ctx.arc(x+8,y-4,1.5,0,7);this.ctx.fill();}
            this.ctx.restore();
        }
        draw() {
            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height); this.ctx.save();
            if(this.shakeTime>0)this.ctx.translate((Math.random()-0.5)*10,(Math.random()-0.5)*10);
            if(this.bgImage.src&&this.bgImage.complete&&this.bgImage.naturalWidth>0)this.ctx.drawImage(this.bgImage,0,0,this.canvas.width,this.canvas.height-GAME_CONFIG.safeZoneHeight);
            this.ctx.fillStyle="#000"; this.ctx.fillRect(0,this.canvas.height-GAME_CONFIG.safeZoneHeight,this.canvas.width,GAME_CONFIG.safeZoneHeight);
            this.blocks.forEach(b=>{
                if(!b.active)return;
                if(this.useOverlayImage&&this.blockImage.src&&this.blockImage.complete&&this.blockImage.naturalWidth>0){ const sx=this.blockImage.naturalWidth/this.canvas.width, sy=this.blockImage.naturalHeight/(this.canvas.height-GAME_CONFIG.safeZoneHeight); this.ctx.drawImage(this.blockImage,b.x*sx,b.y*sy,b.w*sx,b.h*sy,b.x,b.y,b.w,b.h); } else if(this.bgImage.src&&this.bgImage.complete&&this.bgImage.naturalWidth>0) this.ctx.drawImage(this.blurredBgCanvas,b.x,b.y,b.w,b.h,b.x,b.y,b.w,b.h);
                this.ctx.globalAlpha=GAME_CONFIG.blocks.opacity; this.ctx.fillStyle=b.color; this.ctx.fillRect(b.x,b.y,b.w,b.h); this.ctx.globalAlpha=0.3; this.ctx.strokeStyle='#000'; this.ctx.strokeRect(b.x,b.y,b.w,b.h); this.ctx.globalAlpha=1.0;
            });
            if(this.egg && (this.state==='PLAYING'||this.state==='IMPLANTATION')){
                this.ctx.save(); this.ctx.translate(this.egg.x,this.egg.y); this.ctx.shadowBlur=20; this.ctx.shadowColor=GAME_CONFIG.egg.glowColor; this.ctx.beginPath(); this.ctx.arc(0,0,this.egg.radius*(1+0.08*Math.sin(Date.now()/250)),0,Math.PI*2); this.ctx.fillStyle=GAME_CONFIG.egg.membraneColor; this.ctx.fill(); this.ctx.shadowBlur=0; this.ctx.beginPath(); this.ctx.arc(0,0,this.egg.radius*0.6*(1+0.08*Math.sin(Date.now()/250)),0,Math.PI*2); this.ctx.fillStyle=GAME_CONFIG.egg.innerColor; this.ctx.fill(); this.ctx.restore();
            }
            if(this.state!=='VIEW_BG'){ const po=(this.pushTimer>0)?Math.sin((this.pushTimer/10)*Math.PI)*12:0; const pt=this.canvas.height-GAME_CONFIG.paddle.height-GAME_CONFIG.paddle.bottomOffset-po; const highlight = Date.now()<this.speedUpEndTime; this.paddle.draw(this.ctx, pt, GAME_CONFIG.paddle.height, highlight); this.balls.forEach(b => b.draw(this.ctx, this.bombNextHit)); this.items.forEach(i => this.drawItemIcon(i)); }
            this.particleSystem.draw(this.ctx); 
            if(this.state==='WIN'||this.state==='VIEW_BG')this.winParticles.forEach(p=>{this.ctx.font=`${p.size}px sans-serif`;this.ctx.fillStyle=p.color;this.ctx.textAlign="center";this.ctx.fillText("❤",p.x,p.y);});
            this.ctx.restore();
        }
        updateUI() { document.getElementById('scoreDisplay').textContent = `SCORE: ${this.score}`; document.getElementById('livesDisplay').innerHTML = `<span style="color: var(--danger-color)">${"♥".repeat(Math.max(0,this.lives))}</span>`; }
        gameWin() {
            if (this.isDemo) { this.startDemo(); return; } if(this.state === 'WIN') return;
            const T = USER_SETTINGS.TEXT; this.isDemo = false; this.state = 'WIN'; this.finalTimeStr = this.calculateTime();
            this.applyTimeBonus(); SoundManager.play('win'); this.startConfetti(); 
            document.getElementById('launchMessage').classList.remove('visible'); const et = document.getElementById('endTitle'); et.textContent = T.titleGameWin; et.style.color = "var(--success-color)";
            document.getElementById('endScore').textContent = `${T.resultScore} ${this.score}`; document.getElementById('endTime').textContent = `${T.resultTime} ${this.finalTimeStr}`;
            const tbEl = document.getElementById('timeBonus'); tbEl.textContent = `${T.resultTimeBonus} x${this.timeBonusMultiplier.toFixed(2)}`; tbEl.style.display = 'block';
            document.getElementById('viewBgBtn').style.display = 'flex'; document.getElementById('endScreen').classList.remove('hidden'); document.querySelector('.demo-indicator')?.remove(); document.getElementById('gameContainer').style.cursor = 'auto';
            document.getElementById('bossBtn').style.display = 'block';
        }
        debugQuickWin() {
            SoundManager.init(); this.isDemo = false; this.lives = 5; this.score = 0; this.gameStartTime = Date.now() - 300000; this.state = 'WIN';
            document.getElementById('startScreen').classList.add('hidden'); document.querySelector('.demo-indicator')?.remove(); this.startConfetti();
            const T = USER_SETTINGS.TEXT; document.getElementById('endTitle').textContent = T.titleGameWin; document.getElementById('endTitle').style.color = "var(--success-color)";
            document.getElementById('endScore').textContent = `${T.resultScore} 0`; document.getElementById('endTime').textContent = `${T.resultTime} 05:00`;
            document.getElementById('timeBonus').textContent = `${T.resultTimeBonus} x1.0`; document.getElementById('timeBonus').style.display = 'block';
            this.finalTimeStr = "05:00"; document.getElementById('viewBgBtn').style.display = 'flex'; document.getElementById('endScreen').classList.remove('hidden'); document.getElementById('bossBtn').style.display = 'block'; document.getElementById('gameContainer').style.cursor = 'auto';
        }
        gameOver() {
            const T = USER_SETTINGS.TEXT; this.isDemo = false; this.state = 'GAMEOVER'; this.finalTimeStr = this.calculateTime();
            SoundManager.play('die'); document.getElementById('launchMessage').classList.remove('visible'); 
            const et = document.getElementById('endTitle'); et.textContent = T.titleGameOver; et.style.color = "var(--danger-color)"; 
            document.getElementById('endScore').textContent = `${T.resultScore} ${this.score}`; document.getElementById('endTime').textContent = `${T.resultTime} ${this.finalTimeStr}`; 
            document.getElementById('timeBonus').style.display = 'none'; document.getElementById('viewBgBtn').style.display = 'flex'; document.getElementById('bossBtn').style.display = 'none'; 
            document.getElementById('endScreen').classList.remove('hidden'); document.querySelector('.demo-indicator')?.remove(); document.getElementById('gameContainer').style.cursor = 'auto';
        }
        startConfetti() { for(let i=0; i<50; i++) { this.winParticles.push({ x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height - this.canvas.height, speedY: Math.random() * 3 + 2, sway: Math.random() * Math.PI * 2, color: `hsl(${Math.random()*360}, 80%, 60%)`, size: Math.random() * 20 + 10 }); } }
        shareResult() { const T = USER_SETTINGS.TEXT; const result = this.state === 'WIN' ? T.shareResultWin : T.shareResultLose; const text = `Result: ${result}\nScore: ${this.score}\nTime: ${this.finalTimeStr}\n${USER_SETTINGS.shareUrl}\n`; const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&hashtags=${T.shareHashTags}`; window.open(url, '_blank'); }
        viewBackground() { document.getElementById('endScreen').classList.add('hidden'); this.state = 'VIEW_BG'; showToast(USER_SETTINGS.TEXT.msgViewBg); }
        calculateTime() { const e = Date.now() - this.gameStartTime; const m = Math.floor(e / 60000); const s = Math.floor((e % 60000) / 1000); return `${m}:${s.toString().padStart(2, '0')}`; }

        // タイムボーナス　180＝3分　600＝10分
        applyTimeBonus() {
　　　　    const s=(Date.now()-this.gameStartTime)/1000;
  　　　　　 　 this.timeBonusMultiplier = s <= 180 ? 2.0 : (s >= 600 ? 1.0 : Math.round((2.0 - ((s - 180) / 420)) * 100) / 100);
    　　　　this.score=Math.floor(this.score*this.timeBonusMultiplier);
}

        destroy() { 
            if(this.inputHandler) this.inputHandler.destroy(); 
            if(this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
        }
    }

    // =============================================================================
    // STAGE 2: BOSS BATTLE
    // =============================================================================
    
const STAGE2_CONFIG = {
    
        // ==========================================
        // プレイヤー設定 (自機)
        // ==========================================
        player: {
            width: 10,           // 自機の幅
            height: 35,          // 自機の高さ
            color: '#f0f0f5',    // 機体の色
            speed: 5.0,          // 移動速度
            shotCooldown: 12,    // 発射間隔（フレーム数：小さいほど連射）
            bulletSpeed: 12,     // 弾の速度
            bulletSize: 4        // 弾の大きさ
        },

        // ==========================================
        // ボス設定
        // ==========================================
        boss: { 
            maxHp: 1000,         // 最大HP
            radius: 80,          // 本体の半径
            baseColor: 'rgba(255, 105, 180, 1)',    // 通常時の色
            phase2Color: 'rgba(255, 0, 50, 1)',     // 発狂モード（HP50%以下）の色
            membraneColor: 'rgba(255, 255, 255, 0.3)', // 外膜のエフェクト色

            // --- 極太ビームの設定 ---
            beam: { 
                width: 50,           // 描画上の太さ
                collisionWidth: 20,  // 当たり判定の太さ（描画より少し狭い）
                damage: 2,           // ダメージ量（現在は即死設定なので触れると死ぬ）
                warningTime: 180,    // 予兆（ライン表示）の時間フレーム
                lockTime: 60,        // 狙いが定まるまでの時間
                fireTime: 100,       // ビーム照射時間
                chanceNormal: 0.001, // 通常時の発動確率（毎フレーム判定）
                chanceDesperate: 0.05 // 発狂時の発動確率
            }
        },

        // ==========================================
        // ミニオン（取り巻き）設定
        // ==========================================
        minion: { 
            hp: 200,             // HP
            radius: 15,          // 半径
            color: '#00ffff',    // 色
            speed: 2,            // 旋回速度など
            orbitDist: 150,      // ボスからの距離
            fireChance: 0.01     // 弾を撃ってくる確率（毎フレーム判定）
        }
    };

    class Stage2InputHandler {
        constructor(game) {
            this.game = game; this.keys = {}; this.mouseDown = false; this.mouseX = null; this.mouseY = null;
            this.keydownListener = e => { if (e.repeat) return; this.keys[e.key] = true; this.keys[e.code] = true; if(e.code==='Space') e.preventDefault(); if(e.key === 'Shift') this.game.triggerBomb(); this.mouseX = null; };
            this.keyupListener = e => { this.keys[e.key] = false; this.keys[e.code] = false; };
            this.mousedownListener = e => { if (e.button === 0) this.mouseDown = true; if (e.button === 2) { e.preventDefault(); this.game.triggerBomb(); } };
            this.mouseupListener = e => { if (e.button === 0) this.mouseDown = false; };
            this.mousemoveListener = e => this.updateMouse(e.clientX, e.clientY);
            this.touchStartListener = e => { e.preventDefault(); this.mouseDown = true; this.updateMouse(e.touches[0].clientX, e.touches[0].clientY); };
            this.touchMoveListener = e => { e.preventDefault(); this.updateMouse(e.touches[0].clientX, e.touches[0].clientY); };
            this.touchEndListener = e => { e.preventDefault(); this.mouseDown = false; };
            this.blurListener = () => { this.keys = {}; this.mouseDown = false; };
            
            window.addEventListener('keydown', this.keydownListener); window.addEventListener('keyup', this.keyupListener);
            window.addEventListener('mousedown', this.mousedownListener); window.addEventListener('mouseup', this.mouseupListener);
            window.addEventListener('blur', this.blurListener);

            const c = document.getElementById('gameContainer');
            c.addEventListener('mousemove', this.mousemoveListener);
            c.addEventListener('touchstart', this.touchStartListener, {passive:false});
            c.addEventListener('touchmove', this.touchMoveListener, {passive:false});
            c.addEventListener('touchend', this.touchEndListener, {passive:false});
            c.addEventListener('contextmenu', e => e.preventDefault());
        }
        updateMouse(cx, cy) {
            const r = document.getElementById('gameContainer').getBoundingClientRect();
            if (r.width > 0) { this.mouseX = (cx - r.left) * (this.game.canvas.width / r.width); this.mouseY = (cy - r.top) * (this.game.canvas.height / r.height); }
        }
        destroy() {
            window.removeEventListener('keydown', this.keydownListener); window.removeEventListener('keyup', this.keyupListener);
            window.removeEventListener('mousedown', this.mousedownListener); window.removeEventListener('mouseup', this.mouseupListener);
            window.removeEventListener('blur', this.blurListener);
        }
    }

    class Stage2Player {
        constructor(w, h) { this.w = STAGE2_CONFIG.player.width; this.h = STAGE2_CONFIG.player.height; this.x = w/2; this.y = h - 80; this.cooldown = 0; this.leftBall = true; this.rightBall = true; }
        update(input, cw, ch) {
            if (input.mouseX !== null) { this.x += (input.mouseX - this.x) * 0.2; if (input.mouseY !== undefined) this.y += (input.mouseY - this.y) * 0.2; }
            const s = STAGE2_CONFIG.player.speed;
            if (input.keys['ArrowLeft'] || input.keys['a']) this.x -= s; if (input.keys['ArrowRight'] || input.keys['d']) this.x += s;
            if (input.keys['ArrowUp'] || input.keys['w']) this.y -= s; if (input.keys['ArrowDown'] || input.keys['s']) this.y += s;
            if(this.x < this.w * 2) this.x = this.w * 2; if(this.x > cw - this.w * 2) this.x = cw - this.w * 2;
            if(this.y < 100) this.y = 100; if(this.y > ch - 50) this.y = ch - 50;
            if (this.cooldown > 0) this.cooldown--;
            return ((input.keys[' '] || input.keys['Space'] || input.mouseDown) && this.cooldown <= 0) ? (this.cooldown = STAGE2_CONFIG.player.shotCooldown, true) : false;
        }
        useBomb() { if (this.leftBall) { this.leftBall = false; return { x: this.x - this.w + 2, y: this.y - 5 }; } else if (this.rightBall) { this.rightBall = false; return { x: this.x + this.w - 2, y: this.y - 5 }; } return null; }
        draw(ctx, inv) {
            if(inv && Math.floor(Date.now()/50)%2===0) return; 
            ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = STAGE2_CONFIG.player.color; ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            const r = this.w * 0.9; ctx.beginPath(); if (this.leftBall) ctx.arc(-this.w + 2, this.h - 5, r, 0, Math.PI * 2); if (this.rightBall) ctx.arc(this.w - 2, this.h - 5, r, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.rect(-this.w/2, 0, this.w, this.h); ctx.fill();
            const tw = this.w * 1.1, th = this.w * 1.3; ctx.beginPath(); ctx.moveTo(-this.w/2, 0); ctx.bezierCurveTo(-tw, 0, -tw, -th * 0.6, 0, -th); ctx.bezierCurveTo(tw, -th * 0.6, tw, 0, this.w/2, 0); ctx.fill();
            ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = 'rgba(255, 200, 200, 0.8)'; ctx.beginPath(); ctx.arc(0, -th * 0.5, this.w * 0.4, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        }
    }

    class Stage2Minion {
        constructor(x, y, angle) { this.x = x; this.y = y; this.angle = angle; this.hp = STAGE2_CONFIG.minion.hp; this.active = true; this.r = STAGE2_CONFIG.minion.radius; }
        update(bossX, bossY, playerX, playerY, spawnBullet) {
            this.angle += 0.02; const orbit = STAGE2_CONFIG.minion.orbitDist; this.x = bossX + Math.cos(this.angle) * orbit; this.y = bossY + Math.sin(this.angle) * orbit;
            if (Math.random() < STAGE2_CONFIG.minion.fireChance) { const a = Math.atan2(playerY - this.y, playerX - this.x); spawnBullet(this.x, this.y, { isEnemy: true, angle: a, speed: 3, color: STAGE2_CONFIG.minion.color }); }
        }
        damage(amt) { this.hp -= amt; if (this.hp <= 0) this.active = false; }
        draw(ctx) { ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fillStyle = STAGE2_CONFIG.minion.color; ctx.shadowBlur = 10; ctx.shadowColor = STAGE2_CONFIG.minion.color; ctx.fill(); ctx.shadowBlur = 0; }
    }

    class Stage2Boss {
        constructor(cw, ch) {
            this.x = cw / 2; this.y = 150; this.r = 1; this.targetR = STAGE2_CONFIG.boss.radius; this.hp = STAGE2_CONFIG.boss.maxHp; this.maxHp = STAGE2_CONFIG.boss.maxHp; this.active = true; this.state = 'SPAWN';
            this.time = 0; this.hitFlash = 0; this.deathTimer = 0; this.minionsSpawned = false; this.beam = { active: false, state: 'IDLE', timer: 0, angle: Math.PI/2 };
        }
        update(px, py, spawnBullet, spawnMinion) {
            this.time++; const hpRatio = this.hp / this.maxHp;
            if (this.state === 'SPAWN') { this.r += (this.targetR - this.r) * 0.05; if (Math.abs(this.r - this.targetR) < 1) { this.state = 'FIGHT'; document.getElementById('bossHpDisplay').style.display = 'block'; } }
            if (this.state === 'FIGHT') {
                this.x += Math.sin(this.time * 0.02) * 1.5; this.y = 150 + Math.sin(this.time * 0.03) * 5;
                if (hpRatio < 0.5 && !this.minionsSpawned) { this.minionsSpawned = true; for(let i=0; i<4; i++) spawnMinion(this.x, this.y, (Math.PI*2/4)*i); SoundManager.play('heavy_explosion'); }
                if (hpRatio < 0.5) this.updateBeam(px, py);
                if (this.beam.state !== 'FIRING') {
                    const isDesperate = hpRatio < 0.3; const densityMultiplier = isDesperate ? 8 : 1; const pt = Math.floor(this.time / 400) % 4;
                    if (pt === 0 && this.time % 5 === 0) { for(let k=0; k < densityMultiplier; k++) { const offset = (Math.PI * 2 / densityMultiplier) * k; const a = this.time * 0.08 + offset; spawnBullet(this.x, this.y, { isEnemy: true, angle: a, speed: 2, color: `hsl(${this.time * 2},100%,70%)` }); spawnBullet(this.x, this.y, { isEnemy: true, angle: a + Math.PI, speed: 2, color: `hsl(${this.time * 2 + 180},100%,70%)` }); } }
                    else if (pt === 1 && this.time % 80 === 0) { const baseCount = (hpRatio < 0.5) ? 24 : 16; const count = isDesperate ? baseCount * 2 : baseCount; const loops = isDesperate ? 4 : 1; for(let L=0; L<loops; L++) { setTimeout(() => { for (let i = 0; i < count; i++) { spawnBullet(this.x, this.y, { isEnemy: true, angle: (Math.PI * 2 / count) * i + (L*0.1), speed: 1.5 + Math.sin(i * 132) * 0.5, color: '#ff69b4' }); } }, L * 100); } }
                    else if (pt === 2 && this.time % 50 === 0) { const aa = Math.atan2(py - this.y, px - this.x); const spread = isDesperate ? 8 : (hpRatio < 0.5 ? 2 : 1); for (let i = -spread; i <= spread; i++) { spawnBullet(this.x, this.y, { isEnemy: true, angle: aa + i * 0.1, speed: 2.5 + (isDesperate ? Math.random() : 0), color: '#ff3b30' }); } }
                }
            }
            if (this.state === 'DYING') { this.deathTimer++; this.x += (Math.random() - 0.5) * 10; this.y = 150 + (Math.random() - 0.5) * 10; return true; }
            if (this.hitFlash > 0) this.hitFlash--; return false;
        }
        updateBeam(px, py) {
            if (this.beam.state === 'IDLE') { const freq = (this.hp / this.maxHp < 0.3) ? STAGE2_CONFIG.boss.beam.chanceDesperate : STAGE2_CONFIG.boss.beam.chanceNormal; if (Math.random() < freq) { this.beam.state = 'WARNING'; this.beam.timer = STAGE2_CONFIG.boss.beam.warningTime; this.beam.angle = Math.atan2(py - this.y, px - this.x); } }
            else if (this.beam.state === 'WARNING') { this.beam.timer--; if (this.beam.timer > STAGE2_CONFIG.boss.beam.lockTime) { const targetAngle = Math.atan2(py - this.y, px - this.x); this.beam.angle += (targetAngle - this.beam.angle) * 0.05; } if (this.beam.timer <= 0) { this.beam.state = 'FIRING'; this.beam.timer = STAGE2_CONFIG.boss.beam.fireTime; SoundManager.play('heavy_explosion'); } }
            else if (this.beam.state === 'FIRING') { this.beam.timer--; if (this.beam.timer <= 0) { this.beam.state = 'IDLE'; } }
        }
        damage(amt) { if (this.state !== 'FIGHT') return; this.hp -= amt; this.hitFlash = 3; SoundManager.play('smash'); document.getElementById('bossHpBar').style.width = `${Math.max(0, (this.hp / this.maxHp) * 100)}%`; if (this.hp <= 0) { this.state = 'DYING'; this.beam.state = 'IDLE'; SoundManager.play('die'); } }
        draw(ctx) {
            if (this.state === 'DEAD') return;
            if (this.state === 'FIGHT' && this.beam.state !== 'IDLE') {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.beam.angle);
                if (this.beam.state === 'WARNING') { ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(1000, 0); const isLocked = this.beam.timer <= STAGE2_CONFIG.boss.beam.lockTime; ctx.strokeStyle = isLocked ? `rgba(255, 0, 0, 0.8)` : `rgba(255, 100, 100, 0.4)`; ctx.lineWidth = isLocked ? 4 : 2; ctx.setLineDash(isLocked ? [] : [10, 10]); ctx.stroke(); }
                else if (this.beam.state === 'FIRING') { const w = STAGE2_CONFIG.boss.beam.width; ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000'; ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; ctx.fillRect(0, -w/2, 1200, w); ctx.shadowBlur = 0; ctx.fillStyle = '#ffffff'; ctx.fillRect(0, -w/4, 1200, w/2); }
                ctx.restore();
            }
            ctx.save(); ctx.translate(this.x, this.y);
            const p2 = (this.hp / this.maxHp) < 0.5; const c = p2 ? STAGE2_CONFIG.boss.phase2Color : STAGE2_CONFIG.boss.baseColor;
            if (this.hitFlash > 0 || (this.state === 'DYING' && Math.floor(this.time / 4) % 2 === 0)) { ctx.shadowBlur = 50; ctx.fillStyle = '#fff'; } else { ctx.shadowBlur = 30; ctx.shadowColor = c; ctx.fillStyle = c; }
            ctx.beginPath(); for (let i = 0; i <= 360; i += 10) { const r = i * Math.PI / 180; const rr = this.r + Math.sin(r * 8 + this.time * 0.1) * 5; if (i === 0) ctx.moveTo(Math.cos(r) * rr, Math.sin(r) * rr); else ctx.lineTo(Math.cos(r) * rr, Math.sin(r) * rr); } ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, this.r * 1.1 + Math.sin(this.time * 0.1) * 2, 0, Math.PI * 2); ctx.fillStyle = STAGE2_CONFIG.boss.membraneColor; ctx.fill();
            if (this.hitFlash === 0 && this.state !== 'DYING') { ctx.beginPath(); ctx.arc(0, 0, this.r * 0.4, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,0,100,0.5)'; ctx.fill(); }
            ctx.restore();
        }
    }

    class Stage2Game {
        constructor(initialScore, initialLives, stage1TimeStr) {
            this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d');
            this.score = initialScore; this.lives = initialLives; this.stage1Score = initialScore; this.stage1TimeStr = stage1TimeStr || "00:00";
            this.startBossBattle(); this.loop = this.loop.bind(this); requestAnimationFrame(this.loop);
        }
        startBossBattle() {
            SoundManager.init(); document.getElementById('launchMessage').classList.remove('visible'); document.getElementById('bombFlash').style.opacity = '0';
            document.getElementById('headerBar').style.maxWidth = '600px'; document.getElementById('timeDisplay').style.display = 'none';
            // ボスHPバーを初期化（非表示）
            document.getElementById('bossHpBar').style.width = '100%';
            document.getElementById('bossHpDisplay').style.display = 'none';

            const c = document.getElementById('gameContainer'); c.classList.add('boss-mode'); c.classList.add('playing'); c.style.aspectRatio = '600/1000';
            this.canvas.width = 600; this.canvas.height = 1000; document.getElementById('tutorialText').classList.add('visible');
            this.input = new Stage2InputHandler(this); this.player = new Stage2Player(this.canvas.width, this.canvas.height); this.boss = new Stage2Boss(this.canvas.width, this.canvas.height);
            this.bulletSystem = new BulletSystem(); this.particleSystem = new ParticleSystem(); 
            this.minions = []; this.shakeTime = 0; this.state = 'PLAYING'; this.invincibleTime = 0; this.updateUI();
        }
        triggerBomb() {
            const p = this.player.useBomb();
            if (p) {
                SoundManager.play('smash'); this.shakeTime = 20; const f = document.getElementById('bombFlash'); f.style.opacity = '1'; setTimeout(() => f.style.opacity = '0', 100); this.createExplosion(p.x, p.y, '#eee');
                const bullets = this.bulletSystem.getActiveBullets(); bullets.forEach(b => { if (b.isEnemy) { b.active = false; this.createParticles(b.x, b.y, '#ff3b30'); } });
                this.minions.forEach(m => m.damage(50)); if (this.boss.state === 'FIGHT') this.boss.damage(100);
            }
        }
        update() {
            if (this.shakeTime > 0) this.shakeTime--;
            if (this.state === 'PLAYING') {
                if (this.invincibleTime > 0) this.invincibleTime--;
                if (this.player.update(this.input, 600, 1000)) { this.bulletSystem.spawn(this.player.x, this.player.y - 40, { isEnemy: false }); SoundManager.play('launch'); }
                if (this.boss && this.boss.active) {
                    const die = this.boss.update(this.player.x, this.player.y, (x, y, o) => this.bulletSystem.spawn(x, y, o), (x, y, ang) => this.minions.push(new Stage2Minion(x, y, ang)));
                    if (this.boss.state === 'FIGHT') { const dist = Math.sqrt((this.boss.x - this.player.x)**2 + (this.boss.y - (this.player.y-6))**2); if(dist < this.boss.r + 10) this.playerHit(); }
                    if (this.boss.beam.state === 'FIRING') { if (this.checkBeamCollision(this.boss, this.player)) { this.playerHit(); } }
                    if (die) {
                        this.shakeTime = 5; if (this.boss.deathTimer % 5 === 0) { SoundManager.play('heavy_explosion'); this.createExplosion(this.boss.x + (Math.random() - 0.5) * 150, this.boss.y + (Math.random() - 0.5) * 150, '#fff'); }
                        if (this.boss.deathTimer === 540) { document.getElementById('whiteoutLayer').style.opacity = '1'; this.bulletSystem.clear(); this.minions.forEach(m => m.active = false); }
                        if (this.boss.deathTimer > 720) { this.boss.state = 'DEAD'; this.boss.active = false; this.gameWin(); }
                    }
                }
                this.minions.forEach(m => { if(m.active) m.update(this.boss.x, this.boss.y, this.player.x, this.player.y, (x, y, o) => this.bulletSystem.spawn(x, y, o)); 
                    if(m.active && Math.sqrt((m.x - this.player.x)**2 + (m.y - (this.player.y-6))**2) < m.r + 10) { this.playerHit(); } 
                });
                this.minions = this.minions.filter(m => m.active);
                this.bulletSystem.update(600, 1000);
                const bullets = this.bulletSystem.getActiveBullets();
                bullets.forEach(b => {
                    if (!b.isEnemy) {
                        if (this.boss.state === 'FIGHT' && Math.sqrt((b.x - this.boss.x) ** 2 + (b.y - this.boss.y) ** 2) < this.boss.r) { this.boss.damage(1); b.active = false; this.createParticles(b.x, b.y, '#fff'); this.score += 10; }
                        this.minions.forEach(m => { if (m.active && Math.sqrt((b.x - m.x)**2 + (b.y - m.y)**2) < m.r) { m.damage(20); b.active = false; this.createParticles(b.x, b.y, '#00ffff'); this.score += 50; } });
                    }
                    if (b.isEnemy && Math.sqrt((b.x - this.player.x) ** 2 + (b.y - (this.player.y - 6)) ** 2) < 6) { this.playerHit(); b.active = false; }
                });
                this.updateUI();
            }
            this.particleSystem.update();
        }
        checkBeamCollision(boss, player) {
            const bx = boss.x, by = boss.y; 
            const px = player.x, py = player.y - 6; 
            const angle = boss.beam.angle;
            const dx = px - bx; const dy = py - by; const rotatedX = dx * Math.cos(-angle) - dy * Math.sin(-angle); const rotatedY = dx * Math.sin(-angle) + dy * Math.cos(-angle);
            const halfWidth = STAGE2_CONFIG.boss.beam.collisionWidth / 2;
            return (rotatedX > 0 && rotatedX < 1200 && Math.abs(rotatedY) < halfWidth + 5);
        }
        playerHit() { if (this.invincibleTime > 0) return; this.invincibleTime = 60; SoundManager.play('die'); this.lives--; this.updateUI(); this.createParticles(this.player.x, this.player.y, '#f00', 20); if (this.lives <= 0) this.gameOver(); }
        createParticles(x, y, c, n = 5) { for (let i = 0; i < n; i++) this.particleSystem.spawn(x, y, c, 1.0, 5); }
        createExplosion(x, y, c) { for (let i = 0; i < 30; i++) { const a = Math.random() * 6.28, s = Math.random() * 15; this.particleSystem.spawnDirected(x, y, Math.cos(a)*s, Math.sin(a)*s, c, 1.5); } }
        draw() {
            this.ctx.fillStyle = '#111'; this.ctx.fillRect(0, 0, 600, 1000); this.ctx.save();
            if (this.shakeTime > 0) this.ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
            if (this.player) this.player.draw(this.ctx, this.invincibleTime > 0);
            if (this.boss) this.boss.draw(this.ctx);
            this.minions.forEach(m => m.draw(this.ctx));
            this.bulletSystem.draw(this.ctx); this.particleSystem.draw(this.ctx);
            this.ctx.restore();
        }
        updateUI() { const scoreEl = document.getElementById('scoreDisplay'); const livesEl = document.getElementById('livesDisplay'); if (scoreEl) scoreEl.textContent = `SCORE: ${this.score}`; const safeLives = Math.max(0, this.lives); if (livesEl) livesEl.innerHTML = `<span style="color: var(--danger-color)">${"♥".repeat(safeLives)}</span>`; }
        gameWin() {
            if (this.state === 'WIN') return; this.state = 'WIN'; setTimeout(() => document.getElementById('whiteoutLayer').style.opacity = '0', 500);
            this.score += 100000 + (this.lives * 5000); document.getElementById('finalResultScreen').classList.remove('hidden'); document.getElementById('finalTotalScore').textContent = `Total Score: ${this.score}`; document.getElementById('bossHpDisplay').style.display = 'none'; document.getElementById('tutorialText').classList.remove('visible');
            document.getElementById('tweetFinalBtn').onclick = () => { const text = `COMPLETE VICTORY!\nTOTAL SCORE: ${this.score}\n\nStage1\nResult: Stage 1 Cleared!\nScore: ${this.stage1Score}\nTime: ${this.stage1TimeStr}\n${USER_SETTINGS.shareUrl}\n`; window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&hashtags=SpermEXplosion`, '_blank'); }; this.updateUI();
        }
        gameOver() {
            if (this.state === 'GAMEOVER') return; this.state = 'GAMEOVER'; document.getElementById('finalResultScreen').classList.remove('hidden'); document.getElementById('finalTitle').textContent = "DEFEATED"; document.getElementById('finalTitle').style.color = "var(--danger-color)"; document.getElementById('finalSubText').textContent = "Defeated by Brain Storm..."; document.getElementById('finalTotalScore').textContent = `Total Score: ${this.score}`; document.getElementById('bossHpDisplay').style.display = 'none'; document.getElementById('tutorialText').classList.remove('visible');
            document.getElementById('tweetFinalBtn').onclick = () => { const text = `DEFEATED by Brain Storm...\nTOTAL SCORE: ${this.score}\n\nStage1\nResult: Stage 1 Cleared!\nScore: ${this.stage1Score}\nTime: ${this.stage1TimeStr}\n${USER_SETTINGS.shareUrl}\n`; window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&hashtags=SpermEXplosion`, '_blank'); };
        }
        loop() { if (this.state !== 'EXIT') { this.update(); this.draw(); } requestAnimationFrame(this.loop); }
    }

    // =============================================================================
    // Initialization & Event Listeners (Safe)
    // =============================================================================
    const game = new Game();
    document.getElementById('imgToggleBtn').onclick=e=>{e.stopPropagation();game.toggleBlockImage();};
    document.getElementById('muteBtn').onclick=e=>{e.stopPropagation();SoundManager.toggleMute();};
    document.getElementById('darkModeBtn').onclick=e=>{e.stopPropagation();document.body.classList.toggle('dark');};
    document.getElementById('tweetBtn').onclick=e=>{e.stopPropagation();game.shareResult();};
    document.getElementById('retryBtn').onclick=e=>{e.stopPropagation();game.startGame();};
    document.getElementById('viewBgBtn').onclick=e=>{e.stopPropagation();game.viewBackground();};
    document.getElementById('bossBtn').onclick = (e) => {
        e.stopPropagation();
        game.state = 'STAGE2_TRANSITION';
        game.destroy(); 
        document.getElementById('endScreen').classList.add('hidden');
        new Stage2Game(game.score, game.lives, game.finalTimeStr);
    };

    function showToast(m){const t=document.createElement('div');t.className='toast-notification';t.textContent=m;document.body.appendChild(t);requestAnimationFrame(()=>t.classList.add('show'));setTimeout(()=>{t.classList.remove('show');setTimeout(()=>t.remove(),300)},2000);}
    const tt=document.createElement('div');tt.id='global-tooltip';document.body.appendChild(tt); 
    document.addEventListener('mouseover',e=>{const t=e.target.closest('[data-tooltip]');if(t){tt.textContent=t.getAttribute('data-tooltip');tt.style.opacity='1';}}); 
    document.addEventListener('mouseout',e=>{if(e.target.closest('[data-tooltip]'))tt.style.opacity='0';}); 
    document.addEventListener('mousemove',e=>{if(tt.style.opacity==='1'){let l=e.clientX+15,t=e.clientY+15;if(l+tt.offsetWidth>window.innerWidth)l-=tt.offsetWidth+30;if(t+tt.offsetHeight>window.innerHeight)t-=tt.offsetHeight+30;tt.style.left=l+'px';tt.style.top=t+'px';}}); 
});
</script>
</body>
</html>
