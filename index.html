<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>stylish block breaker</title>
<style>
    /* ==========================================================================
       1. デザイン設定 (CSS変数)
       ========================================================================== */
    :root {
        --bg-color: #f2f2f7;
        --card-bg: #ffffff;
        --text-color: #1c1c1e;
        --btn-primary-bg: #1c1c1e;
        --btn-primary-text: #ffffff;
        --input-bg: #e5e5ea;
        --input-border: #d1d1d6;
        --accent-color: #8e8e93;
        --highlight-color: #007aff;
        --danger-color: #ff3b30;
        --success-color: #34c759;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --tooltip-bg: rgba(40, 40, 40, 0.95);
        --tooltip-text: #ffffff;
        --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", sans-serif;
    }

    body.dark {
        --bg-color: #1c1c1e;
        --card-bg: #2c2c2e;
        --text-color: #f2f2f7;
        --input-bg: #151515;
        --input-border: #3a3a3c;
        --btn-primary-bg: #e5e5ea;
        --btn-primary-text: #1c1c1e;
        --accent-color: #d1d1d6;
        --highlight-color: #0a84ff;
        --danger-color: #ff453a;
        --shadow-color: rgba(0, 0, 0, 0.5);
        --tooltip-bg: rgba(240, 240, 240, 0.95);
        --tooltip-text: #1c1c1e;
    }

    body {
        font-family: var(--font-family);
        background: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        overflow: hidden;
        transition: background 0.3s, color 0.3s;
        user-select: none;
        touch-action: none;
    }

    .game-container {
        position: relative;
        width: 100%;
        max-width: 1000px;
        background: #000;
        box-shadow: 0 10px 30px var(--shadow-color);
        border-radius: 12px;
        overflow: hidden;
        transition: height 0.3s ease;
        border: 4px solid transparent; 
        box-sizing: border-box;
        cursor: pointer;
        min-height: 300px; 
    }

    .game-container.drag-over {
        border-color: var(--highlight-color);
        opacity: 0.8;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
        cursor: none; 
    }

    /* UIレイヤー */
    .ui-layer {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 20px;
        box-sizing: border-box;
        z-index: 10;
    }

    .header-info {
        display: flex;
        justify-content: space-between;
        font-size: 24px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        background: rgba(0,0,0,0.3);
        padding: 8px 20px;
        border-radius: 20px;
    }

    /* オーバーレイ (Start/GameOver) */
    .screen-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 50;
        backdrop-filter: blur(4px);
        transition: opacity 0.3s;
        pointer-events: none; 
        color: #fff;
    }
    .screen-overlay.hidden { opacity: 0; pointer-events: none; visibility: hidden; }

    /* テキストスタイル */
    h1 { font-size: 56px; margin: 0 0 10px 0; letter-spacing: 0.05em; pointer-events: none; }
    p.sub-text { font-size: 20px; opacity: 0.8; margin-bottom: 30px; pointer-events: none; }
    .blink { animation: blink 1.5s infinite; }
    @keyframes blink { 50% { opacity: 0.5; } }

    /* 固定ボタン */
    .fixed-btn {
        position: fixed; top: 15px; 
        width: 44px; height: 44px; padding: 0;
        border-radius: 50%;
        z-index: 100;
        pointer-events: auto;
        background: var(--card-bg);
        color: var(--text-color);
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        display: inline-flex; align-items: center; justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
    }
    .fixed-btn:hover { transform: translateY(-1px); opacity: 0.9; }
    .fixed-btn:active { transform: translateY(1px); }
    
    /* ボタンの位置定義 */
    #darkModeBtn { right: 15px; }
    #muteBtn { right: 70px; }
    #imgToggleBtn { right: 125px; } /* 新しい切り替えボタン */

    .fixed-btn svg { width: 22px; height: 22px; fill: currentColor; }
    #muteBtn.muted svg path.sound-wave { display: none; }
    #muteBtn.muted .mute-x { display: block; }

    .toast-notification {
        position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
        background: var(--tooltip-bg); color: var(--tooltip-text);
        padding: 8px 20px; border-radius: 30px;
        font-size: 14px; font-weight: 600;
        opacity: 0; pointer-events: none; z-index: 20000;
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    
    #launchMessage {
        position: absolute; 
        bottom: 80px; 
        left: 0;
        width: 100%; text-align: center;
        color: #fff; font-size: 16px; font-weight: bold; text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        pointer-events: none; opacity: 0; transition: opacity 0.3s;
        z-index: 20;
    }
    #launchMessage.visible { opacity: 1; animation: blink 1.5s infinite; }

</style>
</head>

<body class="dark"> 

<!-- ▼ 固定ボタン群 -->
<!-- 1. ブロック画像切り替えボタン -->
<button id="imgToggleBtn" class="fixed-btn" aria-label="ブロック模様切り替え">
    <svg viewBox="0 0 24 24">
        <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
    </svg>
</button>
<!-- 2. ミュートボタン -->
<button id="muteBtn" class="fixed-btn" aria-label="ミュート">
    <svg viewBox="0 0 24 24">
        <path d="M3 9v6h4l5 5V4L7 9H3z"/>
        <path class="sound-wave" d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        <g class="mute-x" style="display:none">
             <path d="M16 16l4-4m0 0l-4-4m4 4l-4 4m4-4l-4-4" stroke="currentColor" stroke-width="2" />
        </g>
    </svg>
</button>
<!-- 3. ダークモードボタン -->
<button id="darkModeBtn" class="fixed-btn" aria-label="ダークモード切替">
    <svg viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c4.97 0 9-4.03 9-9a9 9 0 0 0-9-9z"/></svg>
</button>

<div class="game-container" id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <div class="header-info">
            <span id="scoreDisplay">SCORE: 0</span>
            <span id="livesDisplay"><span style="color: var(--danger-color)">♥</span>: 3</span>
        </div>
        <div id="launchMessage">CLICK TO LAUNCH</div>
    </div>

    <div id="startScreen" class="screen-overlay">
        <h1>BLOCK BREAKER</h1>
        <p class="sub-text blink">Click to Start</p>
    </div>

    <div id="endScreen" class="screen-overlay hidden">
        <h1 id="endTitle">GAME OVER</h1>
        <p class="sub-text" id="endScore">Score: 0</p>
        <p class="sub-text blink">Click to Retry</p>
    </div>
</div>

<script>
// =============================================================================
// ▼▼▼ ユーザー設定エリア ▼▼▼
// =============================================================================
const USER_SETTINGS = {
    // 1. ゲーム全体の背景画像URL (空欄なら黒背景)
    backgroundImage: "https://cdn.gamerch.com/contents/wiki/4707/entry/24XnbuoP.jpg",

    // 2. ブロックの表面に貼り付ける画像のURL（空欄なら１を背景画像のすりガラスを適用）
    //    ※ 右上の画像アイコンボタンで、この画像と「すりガラス」を切り替え
    blockOverlayImage: "https://cdn.gamerch.com/contents/wiki/4707/entry/lUMPD61O.jpg", 
};
// =============================================================================

/**
 * Stylish Block Breaker v30
 * Organized for easier editing.
 */

const CONFIG = {
    baseWidth: 1000,
    safeZoneHeight: 150,
    defaultBg: USER_SETTINGS.backgroundImage, 

    paddle: { 
        width: 80,
        height: 16,
        color: '#fff',
        bottomOffset: 30,
        highlightColor: '#007aff'
    },
    ball: { 
        radius: 7,
        color: '#fff',
        normalSpeed: 2.5,
        fastSpeed: 9,
        smashSpeedMultiplier: 2.0
    }, 
    blocks: { 
        cols: 32,
        rowHeight: 14,
        padding: 0,
        offsetTop: 0,
        opacity: 0.5,
        // 上部で定義した設定を使用
        overlayImage: USER_SETTINGS.blockOverlayImage 
    },
    colors: [
        '#f0f0f0', '#e0e0e0', '#d0d0d0', '#c0c0c0', '#b0b0b0', 
        '#a0a0a0', '#909090', '#808080', '#707070', '#606060'
    ],
    items: {
        probability: 0.05,
        dropSpeed: 0.5,
        types: [
            { type: 'speedup', color: '#00e5ff', text: 'SPEED UP (3s)' },
            { type: 'multiball', color: '#ffcc00', text: 'MULTI BALL' },
            { type: 'expand', color: '#32d74b', text: 'WIDTH x2' },
            { type: 'shrink', color: '#ff3b30', text: 'WIDTH 1/2' },
            { type: 'lifeup', color: '#ff2d55', text: 'EXTRA LIFE' } 
        ]
    },
    text: {
        score: "SCORE:",
        launch: "CLICK TO LAUNCH",
        gameOver: "GAME OVER",
        gameWin: "ALL CLEARED!",
        bgChanged: "背景画像を変更しました",
        bgReset: "背景をリセットしました"
    }
};

const SoundManager = {
    ctx: null,
    isMuted: false,
    init() {
        if (!this.ctx) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            } catch(e) {}
        }
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    toggleMute() {
        this.isMuted = !this.isMuted;
        document.getElementById('muteBtn').classList.toggle('muted', this.isMuted);
    },
    play(type) {
        if (this.isMuted || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        if (type === 'launch') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(440, t); osc.frequency.linearRampToValueAtTime(880, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.2);
            osc.start(t); osc.stop(t + 0.2);
        } else if (type === 'smash') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.2);
            gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            osc.start(t); osc.stop(t + 0.2);
        } else if (type === 'hit') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(300, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
            osc.start(t); osc.stop(t + 0.1);
        } else if (type === 'block') {
            osc.type = 'square'; osc.frequency.setValueAtTime(800 + Math.random()*200, t);
            gain.gain.setValueAtTime(0.03, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
            osc.start(t); osc.stop(t + 0.08);
        } else if (type === 'item') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(1200, t); osc.frequency.linearRampToValueAtTime(1800, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.2);
            osc.start(t); osc.stop(t + 0.2);
        } else if (type === 'die') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        }
    }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.blurredBgCanvas = document.createElement('canvas');

        this.state = 'MENU';
        this.score = 0;
        this.lives = 3;
        
        this.paddle = { x: 0, width: CONFIG.paddle.width };
        this.balls = [];
        this.blocks = [];
        this.items = [];
        this.particles = [];
        this.speedUpEndTime = 0;
        
        this.pushTimer = 0;
        this.pushMax = 10;
        this.shakeTime = 0;

        // ブロック画像の切り替えモード管理 (true: 画像, false: すりガラス)
        // 初期値は、画像URLが設定されていればtrue
        this.useOverlayImage = !!CONFIG.blocks.overlayImage;

        this.bgImage = new Image();
        this.bgImage.crossOrigin = "anonymous";
        
        this.blockImage = new Image();
        this.blockImage.crossOrigin = "anonymous";
        if (CONFIG.blocks.overlayImage) {
            this.blockImage.src = CONFIG.blocks.overlayImage;
        }

        // HTML属性よりUSER_SETTINGSを優先
        const bgUrl = CONFIG.defaultBg;

        const startInit = () => this.resizeAndReset();

        if (bgUrl) {
            this.bgImage.onload = startInit;
            this.bgImage.onerror = () => {
                console.warn("Background image failed to load.");
                this.bgImage.src = ""; 
                startInit();
            };
            this.bgImage.src = bgUrl;
        } else {
            startInit();
        }

        this.initInput();
        
        const loop = () => {
            this.update();
            this.draw();
            requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
    }

    // ブロック模様切り替え
    toggleBlockImage() {
        if (!CONFIG.blocks.overlayImage) {
            showToast("ブロック用画像が設定されていません");
            return;
        }
        this.useOverlayImage = !this.useOverlayImage;
        if (this.useOverlayImage) {
            showToast("ブロック模様: 画像");
        } else {
            showToast("ブロック模様: すりガラス");
        }
        this.draw(); // 即時反映
    }

    resizeAndReset() {
        let imageHeight;
        if (this.bgImage.src && this.bgImage.complete && this.bgImage.naturalWidth) {
            const aspect = this.bgImage.naturalHeight / this.bgImage.naturalWidth;
            imageHeight = Math.floor(CONFIG.baseWidth * aspect);
        } else {
            imageHeight = 600; 
        }

        const totalHeight = imageHeight + CONFIG.safeZoneHeight;
        this.canvas.width = CONFIG.baseWidth;
        this.canvas.height = totalHeight;
        
        const container = document.getElementById('gameContainer');
        container.style.aspectRatio = `${CONFIG.baseWidth}/${totalHeight}`;
        
        this.createBlurredBackground();

        if (this.state !== 'MENU') {
            this.resetGame(); 
            this.state = 'PLAYING'; 
            document.getElementById('endScreen').classList.add('hidden'); 
        } else {
            this.resetLevel();
        }
        
        this.draw();
    }

    createBlurredBackground() {
        if (!this.bgImage.src || !this.bgImage.complete || this.bgImage.naturalWidth === 0) return;
        this.blurredBgCanvas.width = this.canvas.width;
        this.blurredBgCanvas.height = this.canvas.height;
        const ctx = this.blurredBgCanvas.getContext('2d');
        const drawHeight = this.canvas.height - CONFIG.safeZoneHeight;
        ctx.filter = 'blur(8px)'; 
        ctx.drawImage(this.bgImage, -20, -20, this.canvas.width + 40, drawHeight + 40);
        ctx.filter = 'none';
    }

    initInput() {
        const container = document.getElementById('gameContainer');

        const movePaddle = (clientX) => {
            const rect = this.canvas.getBoundingClientRect();
            if (rect.width === 0) return;
            const scaleX = this.canvas.width / rect.width;
            let x = (clientX - rect.left) * scaleX;
            this.paddle.x = x - this.paddle.width / 2;
        };

        window.addEventListener('mousemove', (e) => movePaddle(e.clientX));
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            movePaddle(e.touches[0].clientX);
        }, { passive: false });

        const handleClick = (e) => {
            SoundManager.init();
            if (this.state === 'MENU' || this.state === 'GAMEOVER' || this.state === 'WIN') {
                this.startGame();
            } else if (this.state === 'PLAYING') {
                const attachedBall = this.balls.find(b => b.isAttached);
                if (attachedBall) {
                    this.tryLaunch();
                } else {
                    if (this.pushTimer === 0) this.pushTimer = this.pushMax;
                }
            }
        };

        container.addEventListener('mousedown', handleClick);
        container.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleClick(e);
        }, { passive: false });

        this.setupDragAndDrop(container);
    }

    setupDragAndDrop(element) {
        element.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); element.classList.add('drag-over'); });
        element.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); element.classList.remove('drag-over'); });
        element.addEventListener('drop', (e) => {
            e.preventDefault(); e.stopPropagation(); element.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) this.loadBackground(file);
        });
    }

    loadBackground(file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            this.bgImage.onload = () => this.resizeAndReset();
            this.bgImage.onerror = () => { showToast("画像の読み込みに失敗しました"); this.resizeAndReset(); };
            this.bgImage.src = ev.target.result;
            showToast(CONFIG.text.bgChanged);
        };
        reader.readAsDataURL(file);
    }

    startGame() {
        this.resetGame();
        this.state = 'PLAYING';
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('endScreen').classList.add('hidden');
        this.canvas.style.cursor = 'none';
    }

    tryLaunch() {
        const attachedBall = this.balls.find(b => b.isAttached);
        if (attachedBall) {
            attachedBall.isAttached = false;
            const angle = -Math.PI / 2 + (Math.random() * 0.5 - 0.25);
            const speed = this.getCurrentTargetSpeed();
            attachedBall.dx = speed * Math.cos(angle);
            attachedBall.dy = speed * Math.sin(angle);
            SoundManager.play('launch');
            document.getElementById('launchMessage').classList.remove('visible');
        }
    }

    resetGame() {
        this.score = 0;
        this.lives = 3;
        this.speedUpEndTime = 0;
        this.pushTimer = 0;
        this.shakeTime = 0;
        this.resetLevel();
        this.updateUI();
    }

    resetLevel() {
        this.paddle.width = CONFIG.paddle.width; 
        this.paddle.x = (this.canvas.width - this.paddle.width) / 2;
        this.items = [];
        this.particles = [];
        this.spawnBall(true); 
        this.createBlocks();
    }

    spawnBall(attached = false) {
        this.balls = [{
            x: this.canvas.width / 2, y: this.canvas.height - 40,
            dx: 0, dy: 0, radius: CONFIG.ball.radius, active: true,
            isAttached: attached, isSmashing: false, trail: []
        }];
        if (attached) {
            document.getElementById('launchMessage').textContent = CONFIG.text.launch;
            document.getElementById('launchMessage').classList.add('visible');
        }
    }

    createBlocks() {
        this.blocks = [];
        const bW = this.canvas.width / CONFIG.blocks.cols;
        const imageAreaHeight = this.canvas.height - CONFIG.safeZoneHeight;
        if (imageAreaHeight <= 0) return; 
        const rows = Math.floor(imageAreaHeight / CONFIG.blocks.rowHeight); 
        const bH = imageAreaHeight / rows;
        for(let r = 0; r < rows; r++) {
            const color = CONFIG.colors[Math.floor((r / rows) * CONFIG.colors.length) % CONFIG.colors.length];
            for(let c = 0; c < CONFIG.blocks.cols; c++) {
                this.blocks.push({ x: c * bW, y: CONFIG.blocks.offsetTop + r * bH, w: bW, h: bH, color: color, active: true });
            }
        }
    }

    getCurrentTargetSpeed() {
        return (Date.now() < this.speedUpEndTime) ? CONFIG.ball.fastSpeed : CONFIG.ball.normalSpeed;
    }

    normalizeBallSpeed(ball) {
        const angle = Math.atan2(ball.dy, ball.dx);
        const speed = this.getCurrentTargetSpeed();
        ball.dx = speed * Math.cos(angle);
        ball.dy = speed * Math.sin(angle);
        ball.isSmashing = false;
    }

    update() {
        if (this.state !== 'PLAYING') return;
        if (this.pushTimer > 0) this.pushTimer--;
        if (this.shakeTime > 0) this.shakeTime--;

        const pushOffset = (this.pushTimer > 0) ? Math.sin((this.pushTimer / this.pushMax) * Math.PI) * 12 : 0;
        const paddleTop = this.canvas.height - CONFIG.paddle.height - CONFIG.paddle.bottomOffset - pushOffset;
        if (this.paddle.x < 0) this.paddle.x = 0;
        if (this.paddle.x + this.paddle.width > this.canvas.width) this.paddle.x = this.canvas.width - this.paddle.width;

        let activeBalls = 0;
        const targetSpeed = this.getCurrentTargetSpeed();

        this.balls.forEach(ball => {
            if (!ball.active) return;
            activeBalls++;
            if (ball.isAttached) {
                ball.x = this.paddle.x + this.paddle.width / 2;
                ball.y = paddleTop - ball.radius - 2;
                return;
            }
            if (ball.isSmashing) { ball.trail.push({ x: ball.x, y: ball.y }); if (ball.trail.length > 8) ball.trail.shift(); } 
            else { ball.trail = []; }

            const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            if (!ball.isSmashing && currentSpeed > 0) {
                const scale = targetSpeed / currentSpeed;
                ball.dx *= scale; ball.dy *= scale;
            } else if (ball.isSmashing && currentSpeed < CONFIG.ball.fastSpeed * 1.5) {
                const s = (CONFIG.ball.fastSpeed * 1.5) / currentSpeed;
                ball.dx *= s; ball.dy *= s;
            }

            ball.x += ball.dx; ball.y += ball.dy;
            let wallHit = false;
            if (ball.x < ball.radius) { ball.x = ball.radius; ball.dx = Math.abs(ball.dx); wallHit = true; }
            else if (ball.x > this.canvas.width - ball.radius) { ball.x = this.canvas.width - ball.radius; ball.dx = -Math.abs(ball.dx); wallHit = true; }
            if (ball.y < ball.radius) { ball.y = ball.radius; ball.dy = Math.abs(ball.dy); wallHit = true; }
            if (wallHit) {
                SoundManager.play('hit');
                if (ball.isSmashing) this.normalizeBallSpeed(ball);
            }

            if (ball.dy > 0 && ball.y + ball.radius >= paddleTop && ball.y - ball.radius <= paddleTop + CONFIG.paddle.height + pushOffset &&
                ball.x >= this.paddle.x && ball.x <= this.paddle.x + this.paddle.width) {
                let hitPoint = (ball.x - (this.paddle.x + this.paddle.width / 2)) / (this.paddle.width / 2);
                const angle = hitPoint * (Math.PI / 3);
                let speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                if (this.pushTimer > 0) {
                    ball.isSmashing = true; speed = CONFIG.ball.fastSpeed * CONFIG.ball.smashSpeedMultiplier; 
                    this.shakeTime = 10; SoundManager.play('smash'); 
                } else {
                    ball.isSmashing = false; SoundManager.play('hit');
                }
                ball.dx = speed * Math.sin(angle); ball.dy = -speed * Math.cos(angle);
                ball.y = paddleTop - ball.radius - 1; 
            }

            if (ball.y > this.canvas.height) ball.active = false;

            for (let i = 0; i < this.blocks.length; i++) {
                const block = this.blocks[i];
                if (!block.active) continue;
                if (ball.x + ball.radius > block.x && ball.x - ball.radius < block.x + block.w && 
                    ball.y + ball.radius > block.y && ball.y - ball.radius < block.y + block.h) {
                    block.active = false; this.score += 100; this.updateUI(); SoundManager.play('block');
                    this.createParticles(block.x + block.w/2, block.y + block.h/2, block.color);
                    if (Math.random() < CONFIG.items.probability) this.dropItem(block.x + block.w/2, block.y + block.h/2);
                    const prevX = ball.x - ball.dx;
                    if (prevX + ball.radius <= block.x || prevX - ball.radius >= block.x + block.w) ball.dx *= -1; else ball.dy *= -1;
                    if (ball.isSmashing) this.normalizeBallSpeed(ball);
                    break;
                }
            }
        });

        if (activeBalls === 0) {
            this.lives--; this.updateUI(); SoundManager.play('die');
            if (this.lives > 0) { this.paddle.width = CONFIG.paddle.width; this.speedUpEndTime = 0; this.spawnBall(true); } else { this.gameOver(); }
        }

        this.items.forEach((item, i) => {
            item.y += CONFIG.items.dropSpeed;
            const paddleTop = this.canvas.height - CONFIG.paddle.height - CONFIG.paddle.bottomOffset;
            if (item.y > paddleTop && item.y < paddleTop + CONFIG.paddle.height &&
                item.x > this.paddle.x && item.x < this.paddle.x + this.paddle.width) {
                this.activateItem(item); this.items.splice(i, 1);
            } else if (item.y > this.canvas.height) this.items.splice(i, 1);
        });

        this.particles.forEach((p, i) => {
            p.x += p.dx; p.y += p.dy; p.life -= 0.02;
            if(p.life <= 0) this.particles.splice(i, 1);
        });

        if (this.blocks.length > 0 && this.blocks.every(b => !b.active)) this.gameWin();
    }

    dropItem(x, y) { this.items.push({ x, y, ...CONFIG.items.types[Math.floor(Math.random() * CONFIG.items.types.length)] }); }

    activateItem(item) {
        SoundManager.play('item'); showToast(item.text);
        switch(item.type) {
            case 'speedup': this.speedUpEndTime = Date.now() + 3000; break;
            case 'multiball':
                const ab = this.balls.find(b => b.active && !b.isAttached);
                if (ab) this.balls.push({ x: ab.x, y: ab.y, dx: -ab.dx, dy: ab.dy, radius: ab.radius, active: true, isAttached: false, isSmashing: ab.isSmashing, trail: [] });
                break;
            case 'expand': this.paddle.width = Math.min(this.paddle.width * 2, CONFIG.paddle.width * 2); break;
            case 'shrink': this.paddle.width = Math.max(this.paddle.width / 2, CONFIG.paddle.width * 0.5); break;
            case 'lifeup': this.lives++; this.updateUI(); break;
        }
    }

    createParticles(x, y, color) {
        for(let i=0; i<6; i++) this.particles.push({ x, y, dx: (Math.random()-0.5)*5, dy: (Math.random()-0.5)*5, color: color, life: 1.0 });
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.save();
        if (this.shakeTime > 0) { const dx = (Math.random() - 0.5) * 10; const dy = (Math.random() - 0.5) * 10; this.ctx.translate(dx, dy); }

        if (this.bgImage.src && this.bgImage.complete && this.bgImage.naturalWidth) {
            const drawHeight = this.canvas.height - CONFIG.safeZoneHeight;
            this.ctx.drawImage(this.bgImage, 0, 0, this.canvas.width, drawHeight);
        }

        this.ctx.fillStyle = "#000000";
        this.ctx.fillRect(0, this.canvas.height - CONFIG.safeZoneHeight, this.canvas.width, CONFIG.safeZoneHeight);

        const drawHeight = this.canvas.height - CONFIG.safeZoneHeight;

        this.blocks.forEach(b => {
            if (b.active) {
                // 画像モードON かつ 画像が有効なら画像を描画
                if (this.useOverlayImage && this.blockImage.src && this.blockImage.complete && this.blockImage.naturalWidth > 0) {
                    const scaleX = this.blockImage.naturalWidth / this.canvas.width;
                    const scaleY = this.blockImage.naturalHeight / drawHeight;
                    
                    this.ctx.drawImage(
                        this.blockImage, 
                        b.x * scaleX, b.y * scaleY, b.w * scaleX, b.h * scaleY, 
                        b.x, b.y, b.w, b.h 
                    );
                }
                // そうでなければ「すりガラス（ぼかし背景）」
                else if (this.bgImage.src && this.bgImage.complete && this.bgImage.naturalWidth > 0) {
                     this.ctx.drawImage(this.blurredBgCanvas, b.x, b.y, b.w, b.h, b.x, b.y, b.w, b.h);
                }

                this.ctx.globalAlpha = CONFIG.blocks.opacity; this.ctx.fillStyle = b.color; this.ctx.fillRect(b.x, b.y, b.w, b.h);
                this.ctx.globalAlpha = 0.3; this.ctx.strokeStyle = '#000000'; this.ctx.lineWidth = 1; this.ctx.strokeRect(b.x, b.y, b.w, b.h);
                this.ctx.globalAlpha = 1.0;
            }
        });
        
        const pushOffset = (this.pushTimer > 0) ? Math.sin((this.pushTimer / this.pushMax) * Math.PI) * 12 : 0;
        const paddleTop = this.canvas.height - CONFIG.paddle.height - CONFIG.paddle.bottomOffset - pushOffset;
        
        this.ctx.fillStyle = CONFIG.paddle.color;
        if (Date.now() < this.speedUpEndTime) { this.ctx.shadowBlur = 20; this.ctx.shadowColor = CONFIG.paddle.highlightColor; } 
        else { this.ctx.shadowBlur = 0; }
        this.ctx.fillRect(this.paddle.x, paddleTop, this.paddle.width, CONFIG.paddle.height);
        this.ctx.shadowBlur = 0; 

        this.balls.forEach(b => {
            if(b.active) {
                if (b.isSmashing && b.trail.length > 0) {
                    this.ctx.beginPath();
                    b.trail.forEach((pos, index) => { if (index === 0) this.ctx.moveTo(pos.x, pos.y); else this.ctx.lineTo(pos.x, pos.y); });
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; this.ctx.lineWidth = b.radius * 2; this.ctx.lineCap = 'round'; this.ctx.stroke();
                }
                this.ctx.fillStyle = CONFIG.ball.color; this.ctx.beginPath(); this.ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2); this.ctx.fill();
                this.ctx.strokeStyle = "rgba(0,0,0,0.8)"; this.ctx.lineWidth = 2; this.ctx.stroke();
            }
        });

        this.items.forEach(item => this.drawItemIcon(item.x, item.y, item.type, item.color));
        this.particles.forEach(p => { this.ctx.globalAlpha = p.life; this.ctx.fillStyle = p.color; this.ctx.fillRect(p.x, p.y, 3, 3); });
        this.ctx.globalAlpha = 1.0;
        this.ctx.restore();
    }

    drawItemIcon(x, y, type, color) {
        const r = 14; 
        this.ctx.save();
        this.ctx.shadowBlur = 10; this.ctx.shadowColor = color; this.ctx.strokeStyle = color; this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, Math.PI * 2); this.ctx.stroke();
        this.ctx.shadowBlur = 0; this.ctx.fillStyle = "#ffffff"; this.ctx.strokeStyle = "#ffffff";
        this.ctx.lineWidth = 2; this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
        this.ctx.beginPath();
        if (type === 'speedup') { this.ctx.moveTo(x + 2, y - 7); this.ctx.lineTo(x - 3, y); this.ctx.lineTo(x + 2, y); this.ctx.lineTo(x - 2, y + 7); this.ctx.stroke(); } 
        else if (type === 'multiball') { this.ctx.arc(x - 5, y + 3, 2.5, 0, Math.PI*2); this.ctx.closePath(); this.ctx.arc(x + 5, y + 3, 2.5, 0, Math.PI*2); this.ctx.closePath(); this.ctx.arc(x, y - 5, 2.5, 0, Math.PI*2); this.ctx.fill(); } 
        else if (type === 'expand') { this.ctx.moveTo(x - 6, y); this.ctx.lineTo(x + 6, y); this.ctx.moveTo(x - 3, y - 3); this.ctx.lineTo(x - 6, y); this.ctx.lineTo(x - 3, y + 3); this.ctx.moveTo(x + 3, y - 3); this.ctx.lineTo(x + 6, y); this.ctx.lineTo(x + 3, y + 3); this.ctx.stroke(); } 
        else if (type === 'shrink') { this.ctx.moveTo(x - 7, y - 3); this.ctx.lineTo(x - 2, y); this.ctx.lineTo(x - 7, y + 3); this.ctx.moveTo(x + 7, y - 3); this.ctx.lineTo(x + 2, y); this.ctx.lineTo(x + 7, y + 3); this.ctx.stroke(); } 
        else if (type === 'lifeup') { this.ctx.font = "bold 20px sans-serif"; this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle"; this.ctx.fillStyle = "#ffffff"; this.ctx.fillText("♥", x, y + 2); }
        this.ctx.restore();
    }

    updateUI() {
        document.getElementById('scoreDisplay').textContent = `${CONFIG.text.score} ${this.score}`;
        document.getElementById('livesDisplay').innerHTML = `<span style="color: var(--danger-color)">♥</span>: ${this.lives}`;
    }

    gameOver() {
        this.state = 'GAMEOVER'; document.getElementById('launchMessage').classList.remove('visible');
        document.getElementById('endTitle').textContent = CONFIG.text.gameOver; document.getElementById('endTitle').style.color = "var(--danger-color)";
        document.getElementById('endScore').textContent = 'Score: ' + this.score; document.getElementById('endScreen').classList.remove('hidden');
        this.canvas.style.cursor = 'auto';
    }

    gameWin() {
        this.state = 'WIN'; document.getElementById('launchMessage').classList.remove('visible');
        document.getElementById('endTitle').textContent = CONFIG.text.gameWin; document.getElementById('endTitle').style.color = "var(--success-color)";
        document.getElementById('endScore').textContent = 'Score: ' + this.score; document.getElementById('endScreen').classList.remove('hidden');
        this.canvas.style.cursor = 'auto';
    }
}

const game = new Game();

// イベントリスナー
document.getElementById('muteBtn').addEventListener('click', (e) => { e.stopPropagation(); SoundManager.toggleMute(); });
document.getElementById('darkModeBtn').addEventListener('click', (e) => { e.stopPropagation(); document.body.classList.toggle('dark'); });
// ★追加: ブロック模様切り替え
document.getElementById('imgToggleBtn').addEventListener('click', (e) => { e.stopPropagation(); game.toggleBlockImage(); });

function showToast(message) {
    const existing = document.querySelector('.toast-notification');
    if (existing) existing.remove();
    const toast = document.createElement('div'); toast.className = 'toast-notification'; toast.textContent = message;
    document.body.appendChild(toast); requestAnimationFrame(() => toast.classList.add('show'));
    setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 300); }, 2000);
}
</script>
</body>
</html>
